# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/honeybadger/all/honeybadger.rbi
#
# honeybadger-3.1.2
module Honeybadger::Logging::Helper
  def d(msg = nil); end
  def debug(msg = nil); end
  def error(msg = nil); end
  def info(msg = nil); end
  def logger; end
  def warn(msg = nil); end
end
class Honeybadger::Logging::Base
  def add(severity, msg); end
  def debug(msg); end
  def debug?; end
  def error(msg); end
  def error?; end
  def fatal(msg); end
  def fatal?; end
  def info(msg); end
  def info?; end
  def level; end
  def unknown(msg); end
  def unknown?; end
  def warn(msg); end
  def warn?; end
end
class Honeybadger::Logging::BootLogger < Honeybadger::Logging::Base
  def add(severity, msg); end
  def flush(logger); end
  def initialize; end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class Honeybadger::Logging::StandardLogger < Honeybadger::Logging::Base
  def add(*args, &block); end
  def debug?(*args, &block); end
  def error?(*args, &block); end
  def info?(*args, &block); end
  def initialize(logger = nil); end
  def level(*args, &block); end
  def warn?(*args, &block); end
  extend Forwardable
end
class Honeybadger::Logging::FormattedLogger < Honeybadger::Logging::StandardLogger
  def add(severity, msg); end
  def format_message(msg); end
end
class Honeybadger::Logging::ConfigLogger < Honeybadger::Logging::StandardLogger
  def add(severity, msg); end
  def caller_location; end
  def debug?; end
  def initialize(config, logger = nil); end
  def supplement(msg, severity); end
  def suppress_debug?; end
  def suppress_tty?(severity); end
end
class Honeybadger::Backend::Response
  def body; end
  def code; end
  def error; end
  def error_message; end
  def initialize(*args); end
  def message; end
  def parse_error(body); end
  def success?; end
end
class Honeybadger::Backend::Base
  def config; end
  def initialize(config); end
  def notify(feature, payload); end
  extend Forwardable
  include Honeybadger::Logging::Helper
end
class Honeybadger::Util::HTTP
  def compress(string, level = nil); end
  def config; end
  def http_connection; end
  def http_headers(headers = nil); end
  def initialize(config); end
  def post(endpoint, payload, headers = nil); end
  def setup_http_connection; end
  extend Forwardable
  include Honeybadger::Logging::Helper
end
class Honeybadger::Backend::Server < Honeybadger::Backend::Base
  def initialize(config); end
  def notify(feature, payload); end
  def payload_headers(payload); end
end
class Honeybadger::Backend::Null < Honeybadger::Backend::Base
  def initialize(*args); end
  def notify(feature, payload); end
end
class Honeybadger::Backend::Test < Honeybadger::Backend::Null
  def notifications; end
  def notify(feature, payload); end
  def self.notifications; end
end
class Honeybadger::Backend::Debug < Honeybadger::Backend::Null
  def notify(feature, payload); end
end
module Honeybadger::Backend
  def self.for(backend); end
  def self.mapping; end
end
class Honeybadger::Util::Revision
  def self.detect(root = nil); end
  def self.from_capistrano(root); end
  def self.from_git; end
  def self.from_heroku; end
end
class Honeybadger::Config
  def [](key); end
  def []=(key, value); end
  def backend; end
  def backend=(backend); end
  def backtrace_filter; end
  def build_file_logger(path); end
  def build_logger; end
  def build_stdout_logger; end
  def ca_bundle_path; end
  def config_path; end
  def config_paths; end
  def configure; end
  def connection_port; end
  def connection_protocol; end
  def debug?; end
  def default_backend; end
  def detect_revision!; end
  def detected_framework; end
  def dev?; end
  def disabled?; end
  def env; end
  def env=(arg0); end
  def exception_filter; end
  def exception_fingerprint; end
  def excluded_request_keys; end
  def framework; end
  def framework=(arg0); end
  def framework_name; end
  def get(key); end
  def ignored_classes; end
  def includes_token?(obj, value); end
  def init!(opts = nil, env = nil); end
  def init_backend!; end
  def init_logging!; end
  def initialize(opts = nil); end
  def load!(framework: nil, env: nil); end
  def load_config_from_disk; end
  def load_plugin?(name); end
  def local_cert_path; end
  def locate_absolute_path(path, root); end
  def log_debug?; end
  def log_level(key = nil); end
  def log_path; end
  def log_stdout?; end
  def logger; end
  def max_queue_size; end
  def params_filters; end
  def public?; end
  def root_regexp; end
  def ruby; end
  def ruby=(arg0); end
  def set(key, value); end
  def to_h(defaults = nil); end
  def to_hash(defaults = nil); end
  def undotify_keys(hash); end
  def yaml; end
  def yaml=(arg0); end
  extend Forwardable
  include Honeybadger::Logging::Helper
end
class Honeybadger::ContextManager
  def _initialize; end
  def clear!; end
  def custom; end
  def custom=(arg0); end
  def get_context; end
  def get_rack_env; end
  def initialize; end
  def rack_env; end
  def rack_env=(arg0); end
  def self.current; end
  def set_context(hash); end
  def set_rack_env(env); end
end
class Honeybadger::Backtrace::Line
  def ==(other); end
  def application?; end
  def file; end
  def file=(arg0); end
  def filtered_file; end
  def filtered_file=(arg0); end
  def filtered_method; end
  def filtered_method=(arg0); end
  def filtered_number; end
  def filtered_number=(arg0); end
  def get_source(file, number, radius = nil); end
  def initialize(file, number, method, filtered_file = nil, filtered_number = nil, filtered_method = nil, source_radius = nil); end
  def inspect; end
  def method; end
  def method=(arg0); end
  def number; end
  def number=(arg0); end
  def self.parse(unparsed_line, opts = nil); end
  def source; end
  def source_radius; end
  def source_radius=(arg0); end
  def to_s; end
end
class Honeybadger::Backtrace
  def ==(other); end
  def application_lines; end
  def application_lines=(arg0); end
  def as_json(options = nil); end
  def initialize(lines); end
  def inspect; end
  def lines; end
  def lines=(arg0); end
  def self.parse(ruby_backtrace, opts = nil); end
  def self.split_multiline_backtrace(backtrace); end
  def to_a; end
  def to_ary; end
  def to_json(*a); end
  def to_s; end
end
class Honeybadger::Util::Stats
  def self.all; end
  def self.load; end
  def self.memory; end
  def self.run; end
  def self.run_loadavg; end
  def self.run_meminfo; end
end
class Honeybadger::Util::Sanitizer
  def blocks; end
  def can_dup?(obj); end
  def deep_regexps; end
  def enumerable?(data); end
  def filter_cookies(raw_cookies); end
  def filter_key?(key, parents = nil); end
  def filter_url(url); end
  def filters?; end
  def initialize(max_depth: nil, filters: nil); end
  def max_depth; end
  def regexps; end
  def sanitize(data, depth = nil, stack = nil, parents = nil); end
  def sanitize_string(string); end
  def self.sanitize(data); end
  def valid_encoding(string); end
  def valid_encoding?(string); end
end
module Honeybadger::Util::RequestHash
  def self.extract_cgi_data(request); end
  def self.extract_params(request); end
  def self.extract_session(request); end
  def self.extract_url(request); end
  def self.from_env(env); end
end
module Honeybadger::Util::RequestPayload
  def self.build(opts = nil); end
end
class Honeybadger::Notice
  def [](method); end
  def action; end
  def api_key; end
  def as_json(*args); end
  def backtrace; end
  def causes; end
  def cgi_data; end
  def component; end
  def config; end
  def construct_backtrace_filters(opts); end
  def construct_context_hash(opts); end
  def construct_fingerprint(opts); end
  def construct_request_hash(config, opts); end
  def construct_tags(tags); end
  def context; end
  def controller; end
  def error_class; end
  def error_message; end
  def exception; end
  def exception_attribute(attribute, default = nil, &block); end
  def exception_cause(exception); end
  def fingerprint; end
  def fingerprint_from_opts(opts); end
  def from_exception(attribute); end
  def id; end
  def ignore?; end
  def ignore_by_callbacks?; end
  def ignore_by_class?(ignored_class = nil); end
  def ignore_by_origin?; end
  def initialize(config, opts = nil); end
  def local_variables; end
  def local_variables_from_exception(exception, config); end
  def monkey_patch_action_dispatch_test_process!; end
  def now; end
  def opts; end
  def parameters; end
  def params; end
  def params_filters; end
  def parse_backtrace(backtrace); end
  def pid; end
  def rack_env; end
  def rails_params_filters; end
  def request_hash; end
  def request_sanitizer; end
  def s(data); end
  def send_local_variables?(config); end
  def session; end
  def source; end
  def stats; end
  def tags; end
  def to_json(*a); end
  def unwrap_causes(exception); end
  def unwrap_exception(exception); end
  def url; end
  extend Forwardable
end
class Honeybadger::Plugin
  def execution; end
  def executions; end
  def initialize(name); end
  def load!(config); end
  def loaded?; end
  def name; end
  def ok?(config); end
  def requirement; end
  def requirements; end
  def reset!; end
  def self.instances; end
  def self.load!(config); end
  def self.name_from_caller(caller); end
  def self.register(name = nil); end
end
class Honeybadger::Plugin::Execution
  def block; end
  def call; end
  def config; end
  def initialize(config, &block); end
  def logger(*args, &block); end
  extend Forwardable
end
class Honeybadger::Worker
  def add_throttle(t); end
  def backend(*args, &block); end
  def can_start?; end
  def config; end
  def del_throttle; end
  def flush; end
  def handle_response(msg, response); end
  def initialize(config); end
  def marker; end
  def mutex; end
  def notify_backend(payload); end
  def pid; end
  def push(msg); end
  def queue; end
  def release_marker; end
  def run; end
  def send_now(msg); end
  def shutdown!; end
  def shutdown; end
  def signal_marker(marker); end
  def start; end
  def suspend(interval); end
  def thread; end
  def throttle_interval; end
  def throttles; end
  def work(msg); end
  extend Forwardable
  include Honeybadger::Logging::Helper
end
class Honeybadger::Worker::Queue < Thread::Queue
  def initialize(max_size); end
  def max_size; end
  def push(msg); end
end
class Honeybadger::Agent
  def backtrace_filter(*args, &block); end
  def clear!; end
  def config; end
  def configure(*args, &block); end
  def context(hash = nil); end
  def context_manager; end
  def exception_filter(*args, &block); end
  def exception_fingerprint(*args, &block); end
  def flush; end
  def get_context; end
  def init!(*args, &block); end
  def init_worker; end
  def initialize(opts = nil); end
  def notify(exception_or_opts, opts = nil); end
  def push(object); end
  def self.instance; end
  def self.instance=(instance); end
  def send_now(object); end
  def stop(force = nil); end
  def validate_notify_opts!(opts); end
  def with_rack_env(rack_env, &block); end
  def worker; end
  extend Forwardable
  include Honeybadger::Logging::Helper
end
module Honeybadger
  def backtrace_filter(*args, &block); end
  def config(*args, &block); end
  def configure(*args, &block); end
  def context(*args, &block); end
  def exception_filter(*args, &block); end
  def exception_fingerprint(*args, &block); end
  def flush(*args, &block); end
  def get_context(*args, &block); end
  def init!(*args, &block); end
  def load_plugins!; end
  def notify(exception_or_opts, opts = nil); end
  def start(config = nil); end
  def stop(*args, &block); end
  def with_rack_env(*args, &block); end
  extend Forwardable
  extend Honeybadger
end
class Honeybadger::Rack::ErrorNotifier
  def agent; end
  def call(env); end
  def config(*args, &block); end
  def framework_exception(env); end
  def ignored_user_agent?(env); end
  def initialize(app, agent = nil); end
  def logger(*args, &block); end
  def notify_honeybadger(exception, env); end
  extend Forwardable
end
class Honeybadger::Rack::UserInformer
  def agent; end
  def call(env); end
  def config(*args, &block); end
  def initialize(app, agent = nil); end
  def logger(*args, &block); end
  def replacement(with); end
  extend Forwardable
end
class Honeybadger::Rack::UserFeedback
  def action; end
  def agent; end
  def call(env); end
  def config(*args, &block); end
  def custom_template_file; end
  def custom_template_file?; end
  def initialize(app, agent = nil); end
  def logger(*args, &block); end
  def render_form(error_id, action = nil); end
  def template_file; end
  extend Forwardable
end
class Honeybadger::Config::Mash
  def config; end
  def get(key); end
  def getter?(method_name); end
  def hash; end
  def initialize(config, prefix: nil, hash: nil); end
  def key(method_name); end
  def mash?(method); end
  def method_missing(method_name, *args, &block); end
  def prefix; end
  def respond_to_missing?(method_name, include_private = nil); end
  def setter?(method_name); end
  def to_h; end
  def to_hash; end
end
class Honeybadger::Config::Ruby < Honeybadger::Config::Mash
  def backend; end
  def backend=(backend); end
  def backtrace_filter; end
  def exception_filter; end
  def exception_fingerprint; end
  def logger; end
  def logger=(logger); end
end
module Honeybadger::Config::Env
  def self.cast_value(value, type = nil); end
  def self.new(env = nil); end
end
module Honeybadger::Plugins::Rails::ExceptionsCatcher
  def render_exception(arg, exception); end
end
class Honeybadger::Plugins::Shoryuken::Middleware
  def attempt_threshold; end
  def call(_worker, _queue, sqs_msg, body); end
  def notification_params(body); end
  def receive_count(sqs_msg); end
end
class Honeybadger::Plugins::Sidekiq::Middleware
  def call(worker, msg, queue); end
end
module Honeybadger::Plugins::Thor
  def invoke_command_with_honeybadger(*args); end
  def self.included(base); end
end
module Honeybadger::Plugins::LocalVariables::ExceptionExtension
  def __honeybadger_bindings_stack; end
  def self.included(base); end
  def set_backtrace_with_honeybadger(*args, &block); end
end
module Honeybadger::Plugins::Resque::Extension
  def around_perform_with_honeybadger(*args); end
  def on_failure_with_honeybadger(e, *args); end
  def send_exception_to_honeybadger?(e, args); end
end
module Honeybadger::Plugins::Resque::Installer
  def payload_class_with_honeybadger; end
  def self.included(base); end
end
class Honeybadger::Plugins::DelayedJob::Plugin < Delayed::Plugin
  def self.callback_block; end
end
