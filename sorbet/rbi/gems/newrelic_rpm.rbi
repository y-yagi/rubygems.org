# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/newrelic_rpm/all/newrelic_rpm.rbi
#
# newrelic_rpm-6.3.0.355
module DependencyDetection
  def defer(&block); end
  def dependency_by_name(name); end
  def detect!; end
  def installed?(name); end
  def items; end
  def items=(new_items); end
  def self.defer(&block); end
  def self.dependency_by_name(name); end
  def self.detect!; end
  def self.installed?(name); end
  def self.items; end
  def self.items=(new_items); end
end
class DependencyDetection::Dependent
  def allowed_by_config?; end
  def check_dependencies; end
  def dependencies; end
  def dependencies_satisfied?; end
  def depends_on; end
  def execute; end
  def executed!; end
  def executed; end
  def executes; end
  def initialize; end
  def name; end
  def name=(arg0); end
  def named(new_name); end
end
module NewRelic::VERSION
  def self.build_version_string(*parts); end
end
class NewRelic::LocalEnvironment
  def check_for_delayed_job; end
  def check_for_fastcgi; end
  def check_for_glassfish; end
  def check_for_litespeed; end
  def check_for_mongrel; end
  def check_for_passenger; end
  def check_for_puma; end
  def check_for_rainbows; end
  def check_for_resque; end
  def check_for_sidekiq; end
  def check_for_thin; end
  def check_for_torquebox; end
  def check_for_trinidad; end
  def check_for_unicorn; end
  def check_for_webrick; end
  def discover_dispatcher; end
  def discovered_dispatcher; end
  def executable; end
  def find_class_in_object_space(klass); end
  def initialize; end
  def jruby_rack?; end
  def to_s; end
end
module NewRelic::LanguageSupport
  def bundled_gem?(gem_name); end
  def can_fork?; end
  def constantize(const_name); end
  def gc_profiler_enabled?; end
  def gc_profiler_usable?; end
  def jruby?; end
  def object_space_usable?; end
  extend NewRelic::LanguageSupport
end
module NewRelic::Helper
  def correctly_encoded(string); end
  def instance_method_visibility(klass, method_name); end
  def instance_methods_include?(klass, method_name); end
  def time_to_millis(time); end
  extend NewRelic::Helper
end
class Anonymous_Struct_22 < Struct
  def name; end
  def name=(_); end
  def port; end
  def port=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class NewRelic::Control::Server < Anonymous_Struct_22
  def to_s; end
end
module NewRelic::Control::ServerMethods
  def api_server; end
  def server; end
  def server_from_host(hostname = nil); end
end
class NewRelic::Control
  extend NewRelic::Control::ClassMethods
  include NewRelic::Control::InstanceMethods
  include NewRelic::Control::Instrumentation
  include NewRelic::Control::ServerMethods
end
module NewRelic::Control::Instrumentation
  def _install_instrumentation; end
  def add_instrumentation(pattern); end
  def install_instrumentation; end
  def install_shim; end
  def load_instrumentation_files(pattern); end
end
module NewRelic::Control::ClassMethods
  def camelize(snake_case_name); end
  def instance(create = nil); end
  def load_framework_class(framework); end
  def load_test_framework; end
  def local_env; end
  def new_instance; end
  def newrelic_root; end
  def reset; end
end
class NewRelic::Agent::NullLogger
  def debug(*args); end
  def error(*args); end
  def fatal(*args); end
  def info(*args); end
  def method_missing(method, *args, &blk); end
  def warn(*args); end
end
module NewRelic::Agent::LogOnce
  def clear_already_logged; end
  def log_once(level, key, *msgs); end
end
class NewRelic::Agent::MemoryLogger
  def debug(*msgs, &blk); end
  def dump(logger); end
  def error(*msgs, &blk); end
  def fatal(*msgs, &blk); end
  def info(*msgs, &blk); end
  def initialize; end
  def is_startup_logger?; end
  def level; end
  def level=(arg0); end
  def log_exception(level, e, backtrace_level = nil); end
  def log_formatter; end
  def log_formatter=(arg0); end
  def messages; end
  def messages=(arg0); end
  def warn(*msgs, &blk); end
  include NewRelic::Agent::LogOnce
end
module NewRelic::Agent::Hostname
  def self.get; end
  def self.get_dyno_prefixes; end
  def self.get_external(host_or_ip); end
  def self.get_fqdn; end
  def self.heroku_dyno_name_prefix(dyno_name); end
  def self.local?(host_or_ip); end
end
class NewRelic::Agent::AgentLogger
  def backtrace_from_exception(e); end
  def create_log(root, override_logger); end
  def create_log_to_file(root); end
  def create_null_logger; end
  def debug(*msgs, &blk); end
  def error(*msgs, &blk); end
  def fatal(*msgs, &blk); end
  def find_or_create_file_path(path_setting, root); end
  def format_and_send(level, *msgs, &block); end
  def gather_startup_logs; end
  def info(*msgs, &blk); end
  def initialize(root = nil, override_logger = nil); end
  def is_startup_logger?; end
  def log_exception(level, e, backtrace_level = nil); end
  def log_formatter=(formatter); end
  def self.log_level_for(level); end
  def set_log_format!; end
  def set_log_level!; end
  def wants_stdout?; end
  def warn(*msgs, &blk); end
  include NewRelic::Agent::LogOnce
end
class NewRelic::Agent::StartupLogger < NewRelic::Agent::MemoryLogger
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
module NewRelic::Control::InstanceMethods
  def [](key); end
  def app; end
  def configure_agent(env, options); end
  def determine_env(options); end
  def dispatcher; end
  def env=(arg0); end
  def framework; end
  def handle_invalid_security_settings; end
  def init_plugin(options = nil); end
  def initialize(local_env, config_file_override = nil); end
  def local_env; end
  def newrelic_root; end
  def root; end
  def security_settings_valid?; end
  def settings; end
  def start_agent; end
end
class NewRelic::MetricSpec
  def <=>(o); end
  def ==(o); end
  def eql?(o); end
  def hash; end
  def initialize(metric_name = nil, metric_scope = nil); end
  def inspect; end
  def name; end
  def scope; end
  def to_json(*a); end
  def to_s; end
end
module NewRelic::Coerce
  def float(value, context = nil); end
  def int(value, context = nil); end
  def int_or_nil(value, context = nil); end
  def log_failure(value, type, context, error); end
  def scalar(val); end
  def self.float(value, context = nil); end
  def self.int(value, context = nil); end
  def self.int_or_nil(value, context = nil); end
  def self.log_failure(value, type, context, error); end
  def self.scalar(val); end
  def self.string(value, context = nil); end
  def string(value, context = nil); end
end
class NewRelic::MetricData
  def eql?(o); end
  def hash; end
  def initialize(metric_spec, stats); end
  def inspect; end
  def metric_spec; end
  def metric_spec=(new_spec); end
  def original_spec; end
  def stats; end
  def stats=(arg0); end
  def to_collector_array(encoder = nil); end
  def to_json(*a); end
  def to_s; end
  include NewRelic::Coerce
end
class NewRelic::Agent::AttributeFilter
  def allows?(allowed_destinations, requested_destination); end
  def allows_key?(key, destination); end
  def apply(attribute_name, default_destinations); end
  def build_rule(attribute_names, destinations, is_include); end
  def build_uri_rule(excluded_attributes); end
  def cache_prefix_blacklist; end
  def high_security?; end
  def include_destinations_for_capture_params(capturing); end
  def initialize(config); end
  def might_allow_prefix?(prefix); end
  def might_allow_prefix_uncached?(prefix); end
  def rules; end
  def setup_key_cache; end
end
class NewRelic::Agent::AttributeFilterRule
  def <=>(other); end
  def attribute_name; end
  def destinations; end
  def empty?; end
  def initialize(attribute_name, destinations, is_include); end
  def is_include; end
  def match?(name); end
  def wildcard; end
end
module NewRelic::CollectionHelper
  def flatten(object); end
  def normalize_params(params); end
  def truncate(string, len = nil); end
end
class NewRelic::NoticedError
  def ==(other); end
  def agent_attributes; end
  def append_attributes(outgoing_params, outgoing_key, source_attributes); end
  def attributes; end
  def attributes=(arg0); end
  def attributes_from_notice_error; end
  def attributes_from_notice_error=(arg0); end
  def base_parameters; end
  def build_agent_attributes(merged_attributes); end
  def build_intrinsic_attributes; end
  def custom_attributes; end
  def exception_class_name; end
  def exception_class_name=(arg0); end
  def exception_id; end
  def expected; end
  def expected=(arg0); end
  def extract_class_name_and_message_from(exception); end
  def file_name; end
  def file_name=(arg0); end
  def initialize(path, exception, timestamp = nil); end
  def intrinsic_attributes; end
  def is_internal; end
  def line_number; end
  def line_number=(arg0); end
  def merge_custom_attributes_from_notice_error(merged_attributes); end
  def merge_custom_attributes_from_transaction(merged_attributes); end
  def merged_custom_attributes(merged_attributes); end
  def message; end
  def message=(arg0); end
  def path; end
  def path=(arg0); end
  def processed_attributes; end
  def request_port; end
  def request_port=(arg0); end
  def request_uri; end
  def request_uri=(arg0); end
  def self.passes_message_whitelist(exception_class); end
  def stack_trace; end
  def stack_trace=(arg0); end
  def timestamp; end
  def timestamp=(arg0); end
  def to_collector_array(encoder = nil); end
  extend NewRelic::CollectionHelper
  include NewRelic::Coerce
end
module NewRelic::SupportabilityHelper
  def record_api_supportability_metric(method_name); end
end
module NewRelic::Agent::EncodingNormalizer
  def self.normalize_object(object); end
  def self.normalize_string(raw_string); end
end
module NewRelic::Agent::EncodingNormalizer::EncodingNormalizer
  def self.normalize(raw_string); end
end
class NewRelic::Agent::Stats
  def ==(other); end
  def apdex_f; end
  def apdex_s; end
  def apdex_t; end
  def call_count; end
  def call_count=(arg0); end
  def increment_count(value = nil); end
  def initialize; end
  def inspect_full; end
  def is_reset?; end
  def max_call_time; end
  def max_call_time=(arg0); end
  def merge!(other); end
  def merge(other_stats); end
  def min_call_time; end
  def min_call_time=(arg0); end
  def min_time_less?(other); end
  def record(value = nil, aux = nil, &blk); end
  def record_apdex(bucket, apdex_t); end
  def record_data_point(value, exclusive_time = nil); end
  def reset; end
  def sum_of_squares; end
  def sum_of_squares=(arg0); end
  def to_json(*_); end
  def to_s; end
  def total_call_time; end
  def total_call_time=(arg0); end
  def total_exclusive_time; end
  def total_exclusive_time=(arg0); end
  def trace_call(value, exclusive_time = nil); end
end
class NewRelic::ChainedCall
  def call(sql); end
  def initialize(block1, block2); end
end
class NewRelic::Agent::InboundRequestMonitor
  def deserialize_header(encoded_header, key); end
  def initialize(events); end
  def obfuscator; end
  def setup_obfuscator; end
end
module NewRelic::Agent::Instrumentation::QueueTime
  def parse_frontend_timestamp(headers, now = nil); end
  def parse_timestamp(string); end
  def self.parse_frontend_timestamp(headers, now = nil); end
  def self.parse_timestamp(string); end
  def self.timestamp_string_from_header_value(value); end
  def timestamp_string_from_header_value(value); end
end
class NewRelic::Agent::TransactionMetrics
  def [](key); end
  def _record_metrics(names, value, aux, target, &blk); end
  def each_scoped; end
  def each_unscoped; end
  def has_key?(key); end
  def initialize; end
  def record_scoped_and_unscoped(names, value = nil, aux = nil, &blk); end
  def record_unscoped(names, value = nil, aux = nil, &blk); end
end
module NewRelic::Agent::MethodTracerHelpers
  def trace_execution_scoped(metric_names, options = nil); end
  extend NewRelic::Agent::MethodTracerHelpers
end
module NewRelic::Agent::AttributeProcessing
  def flatten_and_coerce(object, prefix = nil, result = nil, &blk); end
  def flatten_and_coerce_array(array, prefix, result, &blk); end
  def flatten_and_coerce_hash(hash, prefix, result, &blk); end
  def self.flatten_and_coerce(object, prefix = nil, result = nil, &blk); end
  def self.flatten_and_coerce_array(array, prefix, result, &blk); end
  def self.flatten_and_coerce_hash(hash, prefix, result, &blk); end
end
class NewRelic::Agent::Transaction::Attributes
  def add(attributes, key, value); end
  def add_agent_attribute(key, value, default_destinations); end
  def add_agent_attribute_with_key_check(key, value, default_destinations); end
  def add_custom_attribute(key, value); end
  def add_intrinsic_attribute(key, value); end
  def agent_attributes_for(destination); end
  def custom_attributes_for(destination); end
  def exceeds_bytesize_limit?(value, limit); end
  def for_destination(attributes, calculated_destinations, destination); end
  def initialize(filter); end
  def intrinsic_attributes_for(destination); end
  def merge_custom_attributes(other); end
  def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end
  def slice(incoming); end
end
module NewRelic::Agent::HTTPClients::URIUtil
  def self.filter_uri(original); end
  def self.parse_and_normalize_url(url); end
  def self.strip_query_string(fragment); end
end
class NewRelic::Agent::Transaction::RequestAttributes
  def accept; end
  def assign_agent_attributes(txn); end
  def attribute_from_env(request, key); end
  def attribute_from_request(request, attribute_method); end
  def content_length; end
  def content_length_from_request(request); end
  def content_type; end
  def host; end
  def initialize(request); end
  def path_from_request(request); end
  def port; end
  def port_from_request(request); end
  def referer; end
  def referer_from_request(request); end
  def request_method; end
  def request_path; end
  def user_agent; end
end
module NewRelic::Agent::Transaction::Tracing
  def add_segment(segment, parent = nil); end
  def async=(arg0); end
  def async?; end
  def current_segment; end
  def finalize_segments; end
  def record_total_time_metrics; end
  def segment_complete(segment); end
  def segment_limit; end
  def total_time; end
  def total_time=(arg0); end
end
class NewRelic::Agent::DistributedTracePayload
  def assign_intrinsics(transaction, transaction_payload); end
  def caller_transport_type; end
  def caller_transport_type=(type); end
  def http_safe; end
  def id; end
  def id=(arg0); end
  def initialize; end
  def parent_account_id; end
  def parent_account_id=(arg0); end
  def parent_app_id; end
  def parent_app_id=(arg0); end
  def parent_type; end
  def parent_type=(arg0); end
  def priority; end
  def priority=(arg0); end
  def sampled; end
  def sampled=(arg0); end
  def sampled?; end
  def self.assign_initial_intrinsics(transaction, transaction_payload); end
  def self.assign_trusted_account_key(payload, account_id); end
  def self.connected?; end
  def self.current_segment_id(transaction); end
  def self.for_transaction(transaction); end
  def self.from_http_safe(http_safe_payload); end
  def self.from_json(serialized_payload); end
  def self.major_version_matches?(payload); end
  def text; end
  def timestamp; end
  def timestamp=(arg0); end
  def trace_id; end
  def trace_id=(arg0); end
  def transaction_id; end
  def transaction_id=(arg0); end
  def trusted_account_key; end
  def trusted_account_key=(arg0); end
  def valid_transport_type_for(value); end
  def version; end
  def version=(arg0); end
end
module NewRelic::Agent::Transaction::DistributedTracing
  def accept_distributed_trace_payload(payload); end
  def append_distributed_trace_info(transaction_payload); end
  def assign_distributed_trace_intrinsics; end
  def assign_payload_and_sampling_params(payload); end
  def check_payload_ignored(payload); end
  def check_payload_present(payload); end
  def check_required_fields_present(payload); end
  def check_trusted_account(payload); end
  def check_valid_version(payload); end
  def create_distributed_trace_payload; end
  def decode_payload(payload); end
  def distributed_trace?; end
  def distributed_trace_payload; end
  def distributed_trace_payload=(arg0); end
  def distributed_trace_payload_created=(arg0); end
  def distributed_trace_payload_created?; end
  def parent_id; end
  def record_caller_by_duration_metrics; end
  def record_distributed_tracing_metrics; end
  def record_errors_by_caller_metrics; end
  def record_transport_duration_metrics; end
  def trace_id; end
  def transaction_type_suffix; end
  def transport_duration; end
end
module NewRelic::Agent::CrossAppTracing
  def add_message_cat_headers(headers); end
  def append_cat_info(payload); end
  def assign_cross_app_intrinsics; end
  def assign_intrinsic_transaction_attributes(state); end
  def cat_path_hash; end
  def cat_path_hashes; end
  def cat_path_hashes=(arg0); end
  def cat_referring_path_hash; end
  def cat_trip_id; end
  def cross_app_enabled?; end
  def cross_app_payload; end
  def cross_app_payload=(arg0); end
  def cross_application_tracer_enabled?; end
  def extract_appdata(response); end
  def insert_message_headers(headers, txn_guid, trip_id, path_hash, synthetics_header); end
  def insert_request_headers(request, txn_guid, trip_id, path_hash); end
  def is_cross_app?; end
  def is_cross_app_callee?; end
  def is_cross_app_caller; end
  def is_cross_app_caller=(arg0); end
  def is_cross_app_caller?; end
  def message_has_crossapp_request_header?(headers); end
  def obfuscator; end
  def record_cat_path_hash(hash); end
  def record_cross_app_metrics; end
  def reject_messaging_cat_headers(headers); end
  def response_has_crossapp_header?(response); end
  def self.assign_intrinsic_transaction_attributes(state); end
  def self.cross_app_enabled?; end
  def self.cross_application_tracer_enabled?; end
  def self.extract_appdata(response); end
  def self.insert_message_headers(headers, txn_guid, trip_id, path_hash, synthetics_header); end
  def self.insert_request_headers(request, txn_guid, trip_id, path_hash); end
  def self.message_has_crossapp_request_header?(headers); end
  def self.obfuscator; end
  def self.reject_messaging_cat_headers(headers); end
  def self.response_has_crossapp_header?(response); end
  def self.trusted_valid_cross_app_id?(id); end
  def self.trusts?(id); end
  def self.valid_cross_app_id?(xp_id); end
  def self.valid_cross_process_id?; end
  def self.valid_encoding_key?; end
  def trusted_valid_cross_app_id?(id); end
  def trusts?(id); end
  def valid_cross_app_id?(xp_id); end
  def valid_cross_process_id?; end
  def valid_encoding_key?; end
end
class NewRelic::Agent::TransactionTimeAggregator::TransactionStats < Struct
  def elapsed_transaction_time; end
  def elapsed_transaction_time=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def transaction_started_at; end
  def transaction_started_at=(_); end
end
module NewRelic::Agent::TransactionTimeAggregator
  def harvest!(timestamp = nil); end
  def reset!(timestamp = nil); end
  def self.current_thread; end
  def self.harvest!(timestamp = nil); end
  def self.in_transaction?(thread_id = nil); end
  def self.log_missing_elapsed_transaction_time; end
  def self.record_elapsed_transaction_time_until(timestamp, thread_id = nil); end
  def self.reset!(timestamp = nil); end
  def self.set_transaction_start_time(timestamp, thread_id = nil); end
  def self.split_transaction_at_harvest(timestamp, thread_id = nil); end
  def self.thread_by_id(thread_id); end
  def self.thread_is_alive?(thread_id); end
  def self.transaction_start(timestamp = nil); end
  def self.transaction_stop(timestamp = nil, starting_thread_id = nil); end
  def self.transaction_time_in_thread(timestamp, thread_id, entry); end
  def transaction_start(timestamp = nil); end
  def transaction_stop(timestamp = nil, starting_thread_id = nil); end
end
module NewRelic::Agent::Deprecator
  def self.deprecate(method_name, new_method_name = nil, version = nil); end
end
class NewRelic::Agent::Transaction
  def abort_transaction!; end
  def add_agent_attribute(key, value, default_destinations); end
  def add_custom_attributes(p); end
  def agent; end
  def apdex_bucket(duration, current_apdex_t); end
  def apdex_start; end
  def apdex_start=(arg0); end
  def apdex_t; end
  def append_apdex_perf_zone(payload); end
  def append_synthetics_to(payload); end
  def assign_agent_attributes; end
  def assign_intrinsics; end
  def attributes; end
  def background_summary_metrics; end
  def best_name; end
  def calculate_gc_time; end
  def category; end
  def commit!(outermost_node_name); end
  def cpu_burn; end
  def create_initial_segment; end
  def create_nested_segment(category, options); end
  def create_segment(name); end
  def default_name=(name); end
  def duration; end
  def end_time; end
  def exceptions; end
  def exceptions=(arg0); end
  def filtered_params; end
  def filtered_params=(arg0); end
  def finish; end
  def freeze_name_and_execute_if_not_ignored; end
  def gc_start_snapshot; end
  def generate_guid; end
  def generate_payload; end
  def guid; end
  def had_error_affecting_apdex?; end
  def http_response_code; end
  def http_response_code=(arg0); end
  def ignore!; end
  def ignore?; end
  def ignore_apdex!; end
  def ignore_apdex?; end
  def ignore_enduser!; end
  def ignore_enduser?; end
  def ignore_trace?; end
  def include_guid?; end
  def influences_transaction_name?(category); end
  def initial_segment; end
  def initialize(category, options); end
  def instrumentation_state; end
  def is_synthetics_request?; end
  def jruby_cpu_burn; end
  def jruby_cpu_start; end
  def jruby_cpu_start=(arg0); end
  def jruby_cpu_time; end
  def log_frozen_name(name); end
  def merge_metrics; end
  def merge_request_parameters(params); end
  def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end
  def metrics; end
  def name_frozen?; end
  def needs_middleware_summary_metrics?(name); end
  def nest_initial_segment; end
  def nesting_max_depth; end
  def normal_cpu_burn; end
  def notice_error(error, options = nil); end
  def overridden_name=(name); end
  def payload; end
  def priority; end
  def priority=(arg0); end
  def process_cpu; end
  def process_cpu_start; end
  def process_cpu_start=(arg0); end
  def promoted_transaction_name(name); end
  def queue_time; end
  def raw_synthetics_header; end
  def raw_synthetics_header=(arg0); end
  def record_apdex; end
  def record_apdex_metrics(rollup_metric, transaction_prefix, current_apdex_t); end
  def record_exceptions; end
  def record_queue_time; end
  def record_summary_metrics(outermost_node_name); end
  def record_transaction_event; end
  def recording_web_transaction?; end
  def referer; end
  def request_path; end
  def request_port; end
  def response_content_length; end
  def response_content_length=(arg0); end
  def response_content_type; end
  def response_content_type=(arg0); end
  def sampled=(arg0); end
  def sampled?; end
  def segments; end
  def self.abort_transaction!; end
  def self.add_agent_attribute(key, value, default_destinations); end
  def self.apdex_bucket(duration, failed, apdex_t); end
  def self.merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end
  def self.name_from_partial(partial_name, category); end
  def self.nested_transaction_name(name); end
  def self.notice_error(e, options = nil); end
  def self.recording_web_transaction?; end
  def self.set_default_transaction_name(partial_name, category = nil); end
  def self.set_overriding_transaction_name(partial_name, category = nil); end
  def self.start_new_transaction(state, category, options); end
  def self.tl_current; end
  def self.wrap(state, name, category, options = nil); end
  def send_transaction_finished_event; end
  def set_default_transaction_name(name, category); end
  def set_overriding_transaction_name(name, category); end
  def similar_category?(category); end
  def sql_sampler; end
  def start; end
  def start_time; end
  def start_time=(arg0); end
  def state; end
  def state=(arg0); end
  def summary_metrics; end
  def synthetics_account_id; end
  def synthetics_job_id; end
  def synthetics_monitor_id; end
  def synthetics_payload; end
  def synthetics_payload=(arg0); end
  def synthetics_resource_id; end
  def synthetics_version; end
  def threshold; end
  def transaction_name; end
  def transaction_sampler; end
  def transaction_specific_apdex_t; end
  def transaction_trace; end
  def user_defined_rules_ignore?; end
  def web_category?(category); end
  def with_database_metric_name(model, method, product = nil); end
  def xray_session_id; end
  def xray_session_id=(arg0); end
  include NewRelic::Agent::CrossAppTracing
  include NewRelic::Agent::Transaction::DistributedTracing
  include NewRelic::Agent::Transaction::Tracing
end
module NewRelic::Agent::RangeExtensions
  def compute_overlap(range, ranges); end
  def intersects?(r1, r2); end
  def merge(r1, r2); end
  def merge_or_append(range, ranges); end
  def self.compute_overlap(range, ranges); end
  def self.intersects?(r1, r2); end
  def self.merge(r1, r2); end
  def self.merge_or_append(range, ranges); end
end
class NewRelic::Agent::Transaction::AbstractSegment
  def child_complete(segment); end
  def child_start(segment); end
  def children_time; end
  def children_time=(arg0); end
  def children_time_ranges; end
  def children_time_ranges?; end
  def concurrent_children?; end
  def descendant_complete(child, descendant); end
  def duration; end
  def end_time; end
  def exclusive_duration; end
  def finalize; end
  def finish; end
  def finished?; end
  def force_finish; end
  def guid; end
  def initialize(name = nil, start_time = nil); end
  def inspect; end
  def metric_cache; end
  def name; end
  def name=(arg0); end
  def params; end
  def params?; end
  def parent; end
  def parent=(arg0); end
  def range_recorded=(arg0); end
  def range_recorded?; end
  def record_child_time(child); end
  def record_child_time_as_number(child); end
  def record_child_time_as_range(child); end
  def record_exclusive_duration; end
  def record_metrics; end
  def record_metrics=(arg0); end
  def record_metrics?; end
  def record_on_finish=(arg0); end
  def record_on_finish?; end
  def record_scoped_metric=(arg0); end
  def record_scoped_metric?; end
  def run_complete_callbacks; end
  def segment_complete; end
  def start; end
  def start_time; end
  def time_range; end
  def transaction; end
  def transaction=(arg0); end
  def transaction_assigned; end
  def transaction_state; end
end
module NewRelic::Agent::PayloadMetricMapping
  def self.append_mapped_metrics(txn_metrics, sample); end
  def self.map_metric(metric_name, to_add = nil); end
end
module NewRelic::Agent::SpanEventPrimitive
  def allowed?(key); end
  def for_datastore_segment(segment); end
  def for_external_request_segment(segment); end
  def for_segment(segment); end
  def intrinsics_for(segment); end
  def milliseconds_since_epoch(segment); end
  def parent_guid(segment); end
  def truncate(value, max_size = nil); end
  extend NewRelic::Agent::SpanEventPrimitive
  include NewRelic::Coerce
end
class NewRelic::Agent::Transaction::Segment < NewRelic::Agent::Transaction::AbstractSegment
  def append_unscoped_metric(metric); end
  def initialize(name = nil, unscoped_metrics = nil, start_time = nil); end
  def record_metrics; end
  def record_span_event; end
  def segment_complete; end
  def unscoped_metrics; end
end
module NewRelic::Agent::Datastores::MetricHelper
  def self.all_suffix; end
  def self.instance_metric_for(product, host, port_path_or_id); end
  def self.metrics_for(product, operation, collection = nil, generic_product = nil, host = nil, port_path_or_id = nil); end
  def self.metrics_from_sql(product, sql); end
  def self.operation_from_sql(sql); end
  def self.operation_metric_for(product, operation); end
  def self.overridden_operation_and_collection; end
  def self.product_operation_collection_for(product, operation, collection = nil, generic_product = nil); end
  def self.product_rollup(product); end
  def self.product_suffixed_rollup(product, suffix); end
  def self.scoped_metric_for(product, operation, collection = nil); end
  def self.should_override?(overrides, product, generic_product); end
  def self.statement_metric_for(product, collection, operation); end
  def self.suffixed_rollup(suffix); end
  def self.unscoped_metrics_for(product, operation, collection = nil, host = nil, port_path_or_id = nil); end
end
module NewRelic::Agent::Database::ObfuscationHelpers
  def detect_unmatched_pairs(obfuscated, adapter); end
  def obfuscate(sql, adapter); end
  def obfuscate_single_quote_literals(sql); end
  def self.generate_regex(dialect); end
end
class NewRelic::Agent::Database::Obfuscator
  def default_sql_obfuscator(sql); end
  def initialize; end
  def obfuscator; end
  def reset; end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  def set_sql_obfuscator(type, &block); end
  extend Singleton::SingletonClassMethods
  include NewRelic::Agent::Database::ObfuscationHelpers
  include Singleton
end
module NewRelic::Agent::Database::PostgresExplainObfuscator
  def obfuscate(explain); end
  extend NewRelic::Agent::Database::PostgresExplainObfuscator
end
module NewRelic::Agent::Database::ExplainPlanHelpers
  def handle_exception_in_explain; end
  def is_select?(sql); end
  def multiple_queries?(sql); end
  def parameterized?(sql); end
  def process_explain_results_mysql(results); end
  def process_explain_results_mysql2(results); end
  def process_explain_results_postgres(results); end
  def process_explain_results_sqlite(results); end
  def process_resultset(results, adapter); end
  def string_explain_plan_results(results); end
end
module NewRelic::Agent::Database
  def capture_query(query); end
  def close_connections; end
  def explain_sql(statement); end
  def get_connection(config, &connector); end
  def obfuscate_sql(sql); end
  def parse_operation_from_query(sql); end
  def record_sql_method(config_section = nil); end
  def record_sql_method_key(config_section); end
  def set_sql_obfuscator(type, &block); end
  def should_collect_explain_plans?(config_section = nil); end
  def should_record_sql?(config_section = nil); end
  def truncate_query(query); end
  extend NewRelic::Agent::Database
end
class NewRelic::Agent::Database::ConnectionManager
  def close_connections; end
  def get_connection(config, &connector); end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class NewRelic::Agent::Database::Statement
  def adapter; end
  def append_sql(new_sql); end
  def binds; end
  def binds=(arg0); end
  def config; end
  def config=(arg0); end
  def database_name; end
  def database_name=(arg0); end
  def explain; end
  def explainable?; end
  def explainer; end
  def explainer=(arg0); end
  def host; end
  def host=(arg0); end
  def initialize(sql, config = nil, explainer = nil, binds = nil, name = nil, host = nil, port_path_or_id = nil, database_name = nil); end
  def name; end
  def name=(arg0); end
  def port_path_or_id; end
  def port_path_or_id=(arg0); end
  def safe_sql; end
  def sql; end
  def sql=(arg0); end
  def symbolized_adapter(adapter); end
  include NewRelic::Agent::Database::ExplainPlanHelpers
end
class NewRelic::Agent::Transaction::DatastoreSegment < NewRelic::Agent::Transaction::Segment
  def _notice_sql(sql, config = nil, explainer = nil, binds = nil, name = nil); end
  def add_backtrace_parameter; end
  def add_database_name_parameter; end
  def add_instance_parameters; end
  def collection; end
  def database_name; end
  def database_name=(arg0); end
  def host; end
  def initialize(product, operation, collection = nil, host = nil, port_path_or_id = nil, database_name = nil, start_time = nil); end
  def nosql_statement; end
  def notice_nosql_statement(nosql_statement); end
  def notice_sql(sql); end
  def notice_sql_statement; end
  def notice_statement; end
  def operation; end
  def port_path_or_id; end
  def product; end
  def record_metrics; end
  def record_span_event; end
  def record_sql; end
  def record_sql=(arg0); end
  def record_sql?; end
  def segment_complete; end
  def set_instance_info(host = nil, port_path_or_id = nil); end
  def sql_statement; end
end
class NewRelic::Agent::Transaction::ExternalRequestSegment < NewRelic::Agent::Transaction::Segment
  def add_request_headers(request); end
  def add_unscoped_metrics; end
  def cross_app_request?; end
  def cross_process_id; end
  def cross_process_transaction_name; end
  def get_request_metadata; end
  def host; end
  def initialize(library, uri, procedure, start_time = nil); end
  def insert_cross_app_header(request); end
  def insert_distributed_trace_header(request); end
  def insert_synthetics_header(request, header); end
  def library; end
  def name; end
  def obfuscator; end
  def procedure; end
  def process_host_header(request); end
  def process_response_metadata(response_metadata); end
  def read_response_headers(response); end
  def record_metrics; end
  def record_span_event; end
  def segment_complete; end
  def suffixed_rollup_metric; end
  def transaction_guid; end
  def update_segment_name; end
  def uri; end
end
class NewRelic::Agent::Transaction::MessageBrokerSegment < NewRelic::Agent::Transaction::Segment
  def action; end
  def destination_name; end
  def destination_type; end
  def headers; end
  def initialize(action: nil, library: nil, destination_type: nil, destination_name: nil, headers: nil, parameters: nil, start_time: nil); end
  def insert_distributed_trace_header; end
  def library; end
  def name; end
  def transaction_assigned; end
end
class NewRelic::Agent::Tracer
  def self.accept_distributed_trace_payload(payload); end
  def self.clear_state; end
  def self.create_distributed_trace_payload; end
  def self.current_segment; end
  def self.current_transaction; end
  def self.in_transaction(name: nil, partial_name: nil, category: nil, options: nil); end
  def self.log_error(method_name, exception); end
  def self.start_and_add_segment(segment, parent = nil); end
  def self.start_datastore_segment(product: nil, operation: nil, collection: nil, host: nil, port_path_or_id: nil, database_name: nil, start_time: nil, parent: nil); end
  def self.start_external_request_segment(library: nil, uri: nil, procedure: nil, start_time: nil, parent: nil); end
  def self.start_message_broker_segment(action: nil, library: nil, destination_type: nil, destination_name: nil, headers: nil, parameters: nil, start_time: nil, parent: nil); end
  def self.start_segment(name: nil, unscoped_metrics: nil, start_time: nil, parent: nil); end
  def self.start_transaction(name: nil, partial_name: nil, category: nil, **options); end
  def self.start_transaction_or_segment(name: nil, partial_name: nil, category: nil, options: nil); end
  def self.state; end
  def self.state_for(thread); end
  def self.tl_clear; end
  def self.tl_get; end
  def self.tl_state_for(thread); end
  def self.tracing_enabled?; end
end
class NewRelic::Agent::Tracer::State
  def current_transaction; end
  def initialize; end
  def is_execution_traced?; end
  def is_sql_recorded?; end
  def pop_traced; end
  def push_traced(should_trace); end
  def record_sql; end
  def record_sql=(arg0); end
  def reset(transaction = nil); end
  def sql_sampler_transaction_data; end
  def sql_sampler_transaction_data=(arg0); end
  def tracing_enabled?; end
  def untraced; end
  def untraced=(arg0); end
end
class NewRelic::Agent::Threading::AgentThread
  def self.backing_thread_class; end
  def self.backing_thread_class=(clazz); end
  def self.bucket_thread(thread, profile_agent_code); end
  def self.create(label, &blk); end
  def self.list; end
  def self.scrub_backtrace(thread, profile_agent_code); end
end
class NewRelic::Agent::CrossAppPayload
  def as_json_array(content_length); end
  def id; end
  def initialize(id, transaction, transaction_info); end
  def referring_guid; end
  def referring_path_hash; end
  def referring_trip_id; end
  def string_or_false_for(value); end
  def transaction; end
end
class NewRelic::Agent::CrossAppMonitor < NewRelic::Agent::InboundRequestMonitor
  def content_length_from_request(request); end
  def decoded_id(request); end
  def hash_transaction_name(identifier); end
  def insert_response_header(state, request_headers, response_headers); end
  def on_finished_configuring(events); end
  def path_hash(txn_name, seed); end
  def referring_transaction_info(state, request_headers); end
  def register_event_listeners(events); end
  def set_response_headers(transaction, response_headers, content_length); end
  def should_process_request?(id); end
end
module NewRelic::Agent::Autostart
  def agent_should_start?; end
  def blacklisted?(value, &block); end
  def blacklisted_constants?; end
  def blacklisted_executables?; end
  def constant_is_defined?(const_name); end
  def in_blacklisted_rake_task?; end
  extend NewRelic::Agent::Autostart
end
class NewRelic::Agent::Harvester
  def harvest_thread_enabled?; end
  def initialize(events, after_forker = nil); end
  def mark_started(pid = nil); end
  def needs_restart?(pid = nil); end
  def on_transaction(*_); end
  def restart_harvest_thread; end
  def restart_in_children_enabled?; end
  def starting_pid; end
  def starting_pid=(arg0); end
end
class NewRelic::Agent::AuditLogger
  def allowed_endpoint?(uri); end
  def create_log_formatter; end
  def enabled=(arg0); end
  def enabled?; end
  def ensure_log_path; end
  def initialize; end
  def log_request(uri, data, marshaller); end
  def setup?; end
  def setup_logger; end
  def wants_stdout?; end
end
module NewRelic::Agent::NewRelicService::Encoders::Identity
  def self.encode(data, opts = nil); end
end
module NewRelic::Agent::NewRelicService::Encoders::Compressed::Deflate
  def self.encode(data, opts = nil); end
end
module NewRelic::Agent::NewRelicService::Encoders::Compressed::Gzip
  def self.encode(data, opts = nil); end
end
module NewRelic::Agent::NewRelicService::Encoders::Base64CompressedJSON
  def self.encode(data, opts = nil); end
end
class NewRelic::Agent::NewRelicService::Marshaller
  def default_encoder; end
  def prepare(data, options = nil); end
  def return_value(data); end
  def self.human_readable?; end
end
class NewRelic::Agent::NewRelicService::JsonMarshaller < NewRelic::Agent::NewRelicService::Marshaller
  def default_encoder; end
  def dump(ruby, opts = nil); end
  def format; end
  def initialize; end
  def load(data); end
  def self.human_readable?; end
  def warn_for_yajl; end
end
module NewRelic::Agent::NewRelicService::SecurityPolicySettings
  def self.preliminary_settings(security_policies); end
end
class NewRelic::Agent::NewRelicService::SecurityPolicySettings::Validator
  def initialize(preconnect_response); end
  def validate_matching_agent_config!; end
end
class NewRelic::Agent::NewRelicService
  def agent_command_results(results); end
  def agent_id; end
  def agent_id=(id); end
  def analytic_event_data(data); end
  def build_metric_data_array(stats_hash); end
  def cert_file_path; end
  def check_post_size(post_string, endpoint); end
  def close_shared_connection; end
  def collector; end
  def compress_request_if_needed(data, endpoint); end
  def connect(settings = nil); end
  def control; end
  def create_and_start_http_connection; end
  def create_http_connection; end
  def custom_event_data(data); end
  def decompress_response(response); end
  def error_data(unsent_errors); end
  def error_event_data(data); end
  def establish_shared_connection; end
  def force_restart; end
  def generate_remote_method_uri(method); end
  def get_agent_commands; end
  def get_xray_metadata(xray_ids); end
  def handle_serialization_error(method, e); end
  def has_shared_connection?; end
  def http_connection; end
  def initialize(license_key = nil, collector = nil); end
  def invoke_remote(method, payload = nil, options = nil); end
  def license_key; end
  def log_response(response); end
  def marshaller; end
  def metric_data(stats_hash); end
  def preconnect; end
  def profile_data(profile); end
  def record_endpoint_attempts_supportability_metrics(endpoint); end
  def record_error_response_supportability_metrics(response_code); end
  def record_size_supportability_metrics(method, size_bytes, item_count); end
  def record_timing_supportability_metrics(method, start_ts, serialize_finish_ts, request_send_ts, response_check_ts); end
  def remote_method_uri(method); end
  def request_timeout; end
  def request_timeout=(arg0); end
  def reset_remote_method_uris; end
  def send_request(opts); end
  def session(&block); end
  def session_with_keepalive(&block); end
  def session_without_keepalive(&block); end
  def setup_connection_for_ssl(conn); end
  def setup_connection_timeouts(conn); end
  def shutdown(time); end
  def span_event_data(data); end
  def sql_trace_data(sql_traces); end
  def ssl_cert_store; end
  def start_connection(conn); end
  def transaction_sample_data(traces); end
  def user_agent; end
  def valid_to_marshal?(data); end
end
class NewRelic::Agent::PipeService
  def agent_id; end
  def agent_id=(arg0); end
  def analytic_event_data(events); end
  def buffer; end
  def channel_id; end
  def collector; end
  def collector=(arg0); end
  def connect(config); end
  def custom_event_data(events); end
  def error_data(errors); end
  def error_event_data(events); end
  def get_agent_commands; end
  def initialize(channel_id); end
  def marshal_payload(data); end
  def metric_data(unsent_timeslice_data); end
  def pipe; end
  def request_timeout; end
  def request_timeout=(arg0); end
  def session; end
  def shutdown(time); end
  def span_event_data(events); end
  def sql_trace_data(sql); end
  def transaction_sample_data(transactions); end
  def write_to_pipe(endpoint, data); end
end
class NewRelic::Agent::Configuration::DottedHash < Hash
  def dot_flattened(nested_hash, names = nil, result = nil); end
  def initialize(hash, keep_nesting = nil); end
  def inspect; end
  def self.symbolize(hash); end
  def to_hash; end
end
class NewRelic::Agent::Configuration::YamlSource < NewRelic::Agent::Configuration::DottedHash
  def booleanify_values(config, *keys); end
  def failed?; end
  def failures; end
  def failures=(arg0); end
  def file_path; end
  def file_path=(arg0); end
  def generated_for_user; end
  def initialize(path, env); end
  def is_boolean?(value); end
  def license_key; end
  def log_failure(*messages); end
  def process_erb(file); end
  def process_yaml(file, env, config, path); end
  def substitute_transaction_threshold(config); end
  def validate_config_file_path(path); end
  def warn_missing_config_file(path); end
end
module NewRelic::Agent::Configuration
  def self.value_of(key); end
end
class NewRelic::Agent::Configuration::Boolean
  def self.===(o); end
end
class NewRelic::Agent::Configuration::DefaultSource
  def [](*args, &block); end
  def default_values; end
  def defaults; end
  def delete(*args, &block); end
  def each(*args, &block); end
  def has_key?(*args, &block); end
  def initialize; end
  def keys(*args, &block); end
  def merge(*args, &block); end
  def self.agent_enabled; end
  def self.api_host; end
  def self.app_name; end
  def self.audit_log_path; end
  def self.browser_monitoring_loader; end
  def self.config_path; end
  def self.config_search_paths; end
  def self.convert_to_constant_list(raw_value); end
  def self.convert_to_list(value); end
  def self.convert_to_regexp_list(raw_value); end
  def self.dispatcher; end
  def self.framework; end
  def self.host; end
  def self.profiling_available; end
  def self.thread_profiler_enabled; end
  def self.transaction_tracer_transaction_threshold; end
  def self.transform_for(key); end
  def to_hash(*args, &block); end
  extend Forwardable
end
class NewRelic::Agent::Configuration::ServerSource < NewRelic::Agent::Configuration::DottedHash
  def add_event_data(merged_settings, connect_reply); end
  def apply_feature_gates(merged_settings, connect_reply, existing_config); end
  def filter_keys(merged_settings); end
  def fix_transaction_threshold(merged_settings); end
  def initialize(connect_reply, existing_config = nil); end
  def merge_agent_config_hash(merged_settings, connect_reply); end
  def merge_top_level_keys(merged_settings, connect_reply); end
  def ungated_value(key, merged_settings, existing_config); end
end
class NewRelic::Agent::Configuration::EnvironmentSource < NewRelic::Agent::Configuration::DottedHash
  def alias_map; end
  def alias_map=(arg0); end
  def collect_new_relic_environment_variable_keys; end
  def convert_environment_key_to_config_key(key); end
  def initialize; end
  def set_aliases(config_setting, value); end
  def set_config_file; end
  def set_dotted_alias(original_config_setting); end
  def set_key_by_type(config_key, environment_key); end
  def set_log_file; end
  def set_value_from_environment_variable(key); end
  def set_values_from_new_relic_environment_variables; end
  def type_map; end
  def type_map=(arg0); end
end
class NewRelic::Agent::Configuration::HighSecuritySource < NewRelic::Agent::Configuration::DottedHash
  def initialize(local_settings); end
  def record_sql_setting(local_settings, key); end
end
class NewRelic::Agent::Configuration::SecurityPolicySource < NewRelic::Agent::Configuration::DottedHash
  def build_overrides(security_policies); end
  def initialize(security_policies); end
  def self.change_setting(policies, option, new_value); end
  def self.enabled?(option); end
  def self.not_empty?(option); end
  def self.record_sql_enabled?(option); end
end
class NewRelic::Agent::Configuration::Manager
  def [](key); end
  def add_config_for_testing(source, level = nil); end
  def app_names; end
  def apply_mask(hash); end
  def apply_transformations(key, value); end
  def break_label_string_into_pairs(labels); end
  def config_classes_for_testing; end
  def config_stack; end
  def delete_all_configs_for_testing; end
  def evaluate_procs(value); end
  def fetch(key); end
  def finished_configuring?; end
  def flattened; end
  def has_key?(key); end
  def initialize; end
  def invoke_callbacks(direction, source); end
  def keys; end
  def limit_number_of_labels(pairs); end
  def log_config(direction, source); end
  def make_label_hash(pairs, labels = nil); end
  def notify_finished_configuring; end
  def num_configs_for_testing; end
  def parse_labels_from_dictionary; end
  def parse_labels_from_string; end
  def parsed_labels; end
  def register_callback(key, &proc); end
  def remove_config(source); end
  def remove_config_type(sym); end
  def remove_duplicates(pairs); end
  def replace_or_add_config(source); end
  def reset_cache; end
  def reset_to_defaults; end
  def source(key); end
  def to_collector_hash; end
  def transform_from_default(key); end
  def truncate(text, key = nil); end
  def valid_label_item?(item); end
  def valid_label_pairs?(label_pairs); end
end
class NewRelic::Agent::Commands::AgentCommand
  def arguments; end
  def id; end
  def initialize(raw_collector_command); end
  def name; end
end
class NewRelic::Agent::Commands::XraySession
  def activate; end
  def active?; end
  def command_arguments; end
  def deactivate; end
  def duration; end
  def finished?; end
  def id; end
  def initialize(command_arguments); end
  def key_transaction_name; end
  def requested_period; end
  def requested_trace_count; end
  def run_profiler?; end
  def sample_period; end
  def xray_session_name; end
  extend Forwardable
end
class NewRelic::Agent::Commands::XraySessionCollection
  def [](*args, &block); end
  def activate_sessions(incoming_ids); end
  def active_thread_profiling_sessions; end
  def add_session(session); end
  def cleanup_finished_sessions; end
  def deactivate_for_incoming_sessions(incoming_ids); end
  def finished_session_ids; end
  def handle_active_xray_sessions(agent_command); end
  def harvest_thread_profiles; end
  def ids_to_activate(incoming_ids); end
  def ids_to_remove(incoming_ids); end
  def include?(*args, &block); end
  def initialize(backtrace_service, event_listener); end
  def lookup_metadata_for(ids_to_activate); end
  def new_relic_service; end
  def remove_session_by_id(id); end
  def session_id_for_transaction_name(name); end
  def stop_all_sessions; end
  extend Forwardable
end
class NewRelic::Agent::Threading::BacktraceService
  def adjust_polling_time(now, poll_start); end
  def aggregate_backtraces(backtraces, name, start, duration, bucket, thread); end
  def aggregate_global_backtrace(backtrace, bucket, thread); end
  def allowed_bucket?(bucket); end
  def buffer; end
  def buffer_backtrace_for_thread(thread, timestamp, backtrace, bucket); end
  def effective_polling_period; end
  def effective_polling_period=(new_period); end
  def find_effective_polling_period; end
  def harvest(transaction_name); end
  def initialize(event_listener = nil); end
  def need_backtrace?(bucket); end
  def on_transaction_finished(payload); end
  def overhead_percent_threshold; end
  def poll; end
  def profile_agent_code; end
  def profile_agent_code=(arg0); end
  def profiles; end
  def record_polling_time(now, poll_start); end
  def record_skew(poll_start); end
  def record_supportability_metrics(now, poll_start); end
  def running?; end
  def sample_thread(thread); end
  def self.is_resque?; end
  def self.is_supported?; end
  def should_buffer?(bucket); end
  def should_profile_agent_code?; end
  def start; end
  def stop; end
  def subscribe(transaction_name, command_arguments = nil); end
  def subscribed?(transaction_name); end
  def unsubscribe(transaction_name); end
  def update_values_from_profiles; end
  def watching_for_transaction?; end
  def worker_loop; end
  def worker_thread; end
  def worker_thread=(arg0); end
end
class NewRelic::Agent::Commands::AgentCommandRouter
  def active_xray_command?(commands); end
  def backtrace_service; end
  def backtrace_service=(arg0); end
  def call_handler_for(agent_command); end
  def check_for_and_handle_agent_commands; end
  def error(err); end
  def get_agent_commands; end
  def handlers; end
  def harvest!; end
  def harvest_from_thread_profiler_session; end
  def harvest_from_xray_session_collection; end
  def initialize(event_listener = nil); end
  def invoke_command(agent_command); end
  def invoke_commands(agent_commands); end
  def log_profiles(profiles); end
  def merge!(*args); end
  def new_relic_service; end
  def on_before_shutdown(*args); end
  def reset!; end
  def select_handler(agent_command); end
  def stop_xray_sessions; end
  def success; end
  def thread_profiler_session; end
  def thread_profiler_session=(arg0); end
  def unrecognized_agent_command(agent_command); end
  def xray_session_collection; end
  def xray_session_collection=(arg0); end
end
class NewRelic::Agent::EventListener
  def check_for_runaway_subscriptions(event); end
  def clear; end
  def initialize; end
  def notify(event, *args); end
  def runaway_threshold; end
  def runaway_threshold=(arg0); end
  def subscribe(event, &handler); end
end
class NewRelic::Agent::DistributedTraceMonitor < NewRelic::Agent::InboundRequestMonitor
  def on_before_call(request); end
  def on_finished_configuring(events); end
  def transport_type(request); end
end
class NewRelic::Agent::SyntheticsMonitor < NewRelic::Agent::InboundRequestMonitor
  def on_before_call(request); end
  def on_finished_configuring(events); end
  def self.is_supported_version?(incoming_payload); end
  def self.is_trusted?(incoming_payload); end
  def self.is_valid_payload?(incoming_payload); end
  def self.reject_messaging_synthetics_header(headers); end
end
class NewRelic::Agent::Heap
  def <<(item); end
  def [](index); end
  def []=(index, value); end
  def empty?; end
  def fix(index); end
  def heapify_down(parent_index); end
  def heapify_up(child_index); end
  def in_range?(index); end
  def initialize(items = nil, &priority_fn); end
  def left_child_index_for(parent_index); end
  def parent_index_for(child_index); end
  def pop; end
  def priority(index); end
  def push(item); end
  def right_sibling_smaller?(lchild_index); end
  def size; end
  def swap(i, j); end
  def to_a; end
end
class NewRelic::Agent::EventBuffer
  def <<(x); end
  def append(x); end
  def capacity; end
  def capacity=(new_capacity); end
  def full?; end
  def initialize(capacity); end
  def metadata; end
  def note_dropped; end
  def num_dropped; end
  def num_seen; end
  def reset!; end
  def sample_rate; end
  def size; end
  def to_a; end
end
class NewRelic::Agent::PrioritySampledBuffer < NewRelic::Agent::EventBuffer
  def append(priority: nil, event: nil, &blk); end
  def append_event(priority: nil, event: nil, &blk); end
  def capacity=(new_capacity); end
  def captured_lifetime; end
  def decrement_lifetime_counts_by(n); end
  def increment_seen; end
  def initialize(capacity); end
  def metadata; end
  def priority_for(event); end
  def sample_rate_lifetime; end
  def seen_lifetime; end
  def to_a; end
end
class NewRelic::Agent::EventAggregator
  def after_harvest(metadata); end
  def after_initialize; end
  def enabled?; end
  def harvest!; end
  def has_metadata?; end
  def initialize; end
  def merge!(payload, adjust_count = nil); end
  def notify_if_full; end
  def register_capacity_callback; end
  def register_enabled_callback; end
  def reservoir_metadata(metadata); end
  def reset!; end
  def reset_buffer!; end
  def self.buffer_class(klass = nil); end
  def self.capacity_key(key = nil); end
  def self.enabled_fn(fn = nil); end
  def self.enabled_key(key = nil); end
  def self.inherited(subclass); end
  def self.named(named = nil); end
end
class NewRelic::Agent::TransactionEventAggregator < NewRelic::Agent::EventAggregator
  def after_harvest(metadata); end
  def record(priority: nil, event: nil, &blk); end
  def record_sampling_rate(metadata); end
end
class NewRelic::Agent::TimestampSampledBuffer < NewRelic::Agent::PrioritySampledBuffer
  def priority_for(event); end
end
class NewRelic::Agent::SyntheticsEventAggregator < NewRelic::Agent::EventAggregator
  def after_harvest(metadata); end
  def record(event); end
  def record_dropped_synthetics(metadata); end
end
module NewRelic::Agent::TransactionEventPrimitive
  def agent_attributes(attributes); end
  def append_cat_alternate_path_hashes(sample, payload); end
  def append_distributed_trace_intrinsics(sample, payload); end
  def append_optional_attributes(sample, payload); end
  def create(payload); end
  def custom_attributes(attributes); end
  def optionally_append(sample_key, payload_key, sample, payload); end
  extend NewRelic::Agent::TransactionEventPrimitive
  include NewRelic::Coerce
end
class NewRelic::Agent::TransactionEventRecorder
  def create_event(payload); end
  def drop_buffered_data; end
  def initialize; end
  def record(payload); end
  def synthetics_event?(payload); end
  def synthetics_event_aggregator; end
  def transaction_event_aggregator; end
end
class NewRelic::Agent::CustomEventAggregator < NewRelic::Agent::EventAggregator
  def after_harvest(metadata); end
  def after_initialize; end
  def create_event(type, priority, attributes); end
  def note_dropped_event(type); end
  def note_dropped_events(total_count, dropped_count); end
  def record(type, attributes); end
  def record_supportability_metrics(total_count, captured_count, dropped_count); end
  include NewRelic::Coerce
end
class NewRelic::Agent::SpanEventAggregator < NewRelic::Agent::EventAggregator
  def after_harvest(metadata); end
  def record(priority: nil, event: nil, &blk); end
end
class NewRelic::Agent::SamplerCollection
  def add_sampler(sampler_class); end
  def clear; end
  def each(&blk); end
  def initialize(event_listener); end
  def load_samplers; end
  def poll_samplers; end
  def sampler_class_registered?(sampler_class); end
  include Enumerable
end
class NewRelic::Agent::Obfuscator
  def deobfuscate(text); end
  def encode(text); end
  def initialize(key, length = nil); end
  def key_bytes; end
  def obfuscate(text); end
end
class NewRelic::Agent::JavascriptInstrumentor
  def add_attributes(data, txn); end
  def add_ssl_for_http(data); end
  def append_agent_attributes!(txn, atts); end
  def append_custom_attributes!(txn, atts); end
  def browser_timing_config(state); end
  def browser_timing_header; end
  def browser_timing_loader; end
  def data_for_js_agent(transaction); end
  def enabled?; end
  def html_safe_if_needed(string); end
  def initialize(event_listener); end
  def insert_js?(state); end
  def js_enabled_and_ready?; end
  def log_configuration; end
  def missing_config?(key); end
  def obfuscator; end
  include NewRelic::Coerce
end
class NewRelic::Agent::VM::MonotonicGCProfiler
  def initialize; end
  def total_time_s; end
end
class NewRelic::Agent::Utilization::Vendor
  def detect; end
  def endpoint; end
  def headers; end
  def initialize; end
  def key_transforms; end
  def keys; end
  def metadata; end
  def normalize(value); end
  def prepare_response(response); end
  def process_response(response); end
  def record_supportability_metric; end
  def request_metadata; end
  def self.endpoint(endpoint = nil); end
  def self.headers(headers = nil); end
  def self.key_transforms(key_transforms = nil); end
  def self.keys(keys = nil); end
  def self.vendor_name(vendor_name = nil); end
  def transform_key(key); end
  def valid_chars?(value); end
  def valid_length?(value); end
  def vendor_name; end
end
class NewRelic::Agent::Utilization::GCP < NewRelic::Agent::Utilization::Vendor
  def prepare_response(response); end
  def trim_leading(value); end
end
class NewRelic::Agent::Utilization::PCF < NewRelic::Agent::Utilization::Vendor
  def detect; end
  def pcf_keys_present?; end
end
class NewRelic::Agent::UtilizationData
  def append_boot_id(collector_hash); end
  def append_configured_values(collector_hash); end
  def append_docker_info(collector_hash); end
  def append_full_hostname(collector_hash); end
  def append_ip_address(collector_hash); end
  def append_kubernetes_info(collector_hash); end
  def append_vendor_info(collector_hash); end
  def config_hash; end
  def configured_hostname; end
  def configured_logical_processors; end
  def configured_total_ram_mib; end
  def container_id; end
  def cpu_count; end
  def fqdn; end
  def hostname; end
  def ip_addresses; end
  def ram_in_mib; end
  def to_collector_hash; end
end
class NewRelic::EnvironmentReport
  def [](key); end
  def []=(key, value); end
  def data; end
  def initialize; end
  def self.registered_reporters; end
  def self.registered_reporters=(logic); end
  def self.report_on(key, &block); end
  def to_a; end
end
class NewRelic::Agent::AdaptiveSampler
  def initialize(target_samples = nil, period_duration = nil); end
  def register_config_callbacks; end
  def register_sampling_period_callback; end
  def register_sampling_target_callback; end
  def reset_if_period_expired!; end
  def sampled?; end
  def stats; end
end
module NewRelic::Agent::Configuration::EventData
  def from_config(config); end
  def to_config_hash(connect_reply); end
  extend NewRelic::Agent::Configuration::EventData
end
class NewRelic::Agent::Connect::RequestBuilder
  def connect_payload; end
  def environment_report; end
  def initialize(new_relic_service, config); end
  def local_host; end
  def sanitize_environment_report(environment_report); end
end
class NewRelic::Agent::Connect::ResponseHandler
  def add_security_policy_config(security_policies); end
  def add_server_side_config(config_data); end
  def configure_agent(config_data); end
  def initialize(agent, config); end
end
class NewRelic::Agent::Agent
  def initialize; end
  def refresh_attribute_filter; end
  def self.config; end
  def setup_attribute_filter; end
  extend NewRelic::Agent::Agent::ClassMethods
  include NewRelic::Agent::Agent::InstanceMethods
end
module NewRelic::Agent::Agent::ClassMethods
  def instance; end
end
module NewRelic::Agent::Agent::InstanceMethods
  def adaptive_sampler; end
  def after_fork(options = nil); end
  def agent_command_router; end
  def agent_id=(agent_id); end
  def agent_should_start?; end
  def attribute_filter; end
  def check_for_and_handle_agent_commands; end
  def connect(options = nil); end
  def container_for_endpoint(endpoint); end
  def control; end
  def cross_app_encoding_bytes; end
  def cross_app_monitor; end
  def cross_process_id; end
  def custom_event_aggregator; end
  def defer_for_delayed_job?; end
  def determine_home_directory; end
  def drop_buffered_data; end
  def error_collector; end
  def events; end
  def flush_pipe_data; end
  def graceful_disconnect; end
  def harvest_and_send_analytic_event_data; end
  def harvest_and_send_error_event_data; end
  def harvest_and_send_errors; end
  def harvest_and_send_for_agent_commands; end
  def harvest_and_send_from_container(container, endpoint); end
  def harvest_and_send_slowest_sql; end
  def harvest_and_send_span_event_data; end
  def harvest_and_send_timeslice_data; end
  def harvest_and_send_transaction_traces; end
  def harvest_from_container(container, endpoint); end
  def harvest_samplers; end
  def harvest_size(container, items); end
  def harvester; end
  def install_pipe_service(channel_id); end
  def javascript_instrumentor; end
  def log_remote_unavailable(endpoint, e); end
  def merge_data_for_endpoint(endpoint, data); end
  def monotonic_gc_profiler; end
  def pop_trace_execution_flag; end
  def push_trace_execution_flag(should_trace = nil); end
  def record_sql; end
  def reset_objects_with_locks; end
  def revert_to_default_configuration; end
  def send_data_to_endpoint(endpoint, payload, container); end
  def service; end
  def service=(arg0); end
  def set_record_sql(should_record); end
  def shutdown; end
  def span_event_aggregator; end
  def sql_sampler; end
  def start; end
  def start_worker_thread(connection_options = nil); end
  def started?; end
  def stats_engine; end
  def stop_event_loop; end
  def synthetics_event_aggregator; end
  def transaction_event_aggregator; end
  def transaction_event_recorder; end
  def transaction_rules; end
  def transaction_rules=(arg0); end
  def transaction_sampler; end
  def transmit_data; end
  def transmit_event_data; end
  def transmit_single_data_type(harvest_method, supportability_name); end
  def transmit_span_event_data; end
  def trap_signals_for_litespeed; end
  def untraced_graceful_disconnect; end
  include NewRelic::Agent::Agent::InstanceMethods::Connect
  include NewRelic::Agent::Agent::InstanceMethods::Start
  include NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread
end
module NewRelic::Agent::Agent::InstanceMethods::Start
  def already_started?; end
  def app_name_configured?; end
  def check_config_and_start_agent; end
  def connect_in_foreground; end
  def correct_license_length; end
  def defer_for_resque?; end
  def disabled?; end
  def has_correct_license_key?; end
  def has_license_key?; end
  def in_resque_child_process?; end
  def install_exit_handler; end
  def log_app_name; end
  def log_dispatcher; end
  def log_environment; end
  def log_ignore_url_regexes; end
  def log_startup; end
  def log_version_and_pid; end
  def monitoring?; end
  def setup_and_start_agent(options = nil); end
  def should_install_exit_handler?; end
  def sinatra_classic_app?; end
  def using_forking_dispatcher?; end
end
module NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread
  def catch_errors; end
  def create_and_run_event_loop; end
  def create_event_loop; end
  def deferred_work!(connection_options); end
  def handle_force_disconnect(error); end
  def handle_force_restart(error); end
  def handle_other_error(error); end
end
module NewRelic::Agent::Agent::InstanceMethods::Connect
  def apdex_f; end
  def connect_attempts; end
  def connect_attempts=(arg0); end
  def connect_retry_period; end
  def connect_to_server; end
  def connected?; end
  def disconnect; end
  def disconnected?; end
  def environment_for_connect; end
  def handle_license_error(error); end
  def handle_unrecoverable_agent_error(error); end
  def log_collector_messages(messages); end
  def log_connection(config_data); end
  def log_error(error); end
  def note_connect_failure; end
  def should_connect?(force = nil); end
  def signal_connected; end
  def wait_on_connect(timeout); end
  def waited_on_connect?; end
end
module NewRelic::Agent::MethodTracer
  def self.extended(clazz); end
  def self.included(clazz); end
  def trace_execution_scoped(metric_names, options = nil); end
  def trace_execution_unscoped(metric_names, options = nil); end
end
module NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer
  def assemble_code_header(method_name, metric_name_code, options); end
  def check_for_illegal_keys!(method_name, options); end
  def check_for_push_scope_and_metric(options); end
  def code_to_eval(method_name, metric_name_code, options); end
  def default_metric_name_code(method_name); end
  def derived_class_name; end
  def method_with_push_scope(method_name, metric_name_code, options); end
  def method_without_push_scope(method_name, metric_name_code, options); end
  def newrelic_method_exists?(method_name); end
  def traced_method_exists?(method_name, metric_name_code); end
  def validate_options(method_name, options); end
end
module NewRelic::Agent::MethodTracer::ClassMethods
  def _add_method_tracer_now(method_name, metric_name_code, options); end
  def _sanitize_name(name); end
  def _traced_method_name(method_name, metric_name); end
  def _untraced_method_name(method_name, metric_name); end
  def add_method_tracer(method_name, metric_name_code = nil, options = nil); end
  def remove_method_tracer(method_name, metric_name_code); end
  include NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer
end
class NewRelic::Agent::WorkerLoop
  def initialize(opts = nil); end
  def iterations; end
  def keep_running?; end
  def period; end
  def period=(arg0); end
  def propagate_errors; end
  def propagate_errors=(arg0); end
  def run(period = nil, &block); end
  def run_task; end
  def schedule_next_invocation; end
  def setup(period, task); end
  def stop; end
  def under_duration?; end
  def under_limit?; end
end
class NewRelic::Agent::EventLoop::Timer
  def advance(amount); end
  def calculate_next_fire_time; end
  def due?(now = nil); end
  def event; end
  def finished?; end
  def initialize(interval, event, repeat = nil); end
  def interval; end
  def last_fired_at; end
  def last_interval_start; end
  def next_fire_time; end
  def reschedule; end
  def set_fired_time; end
end
class NewRelic::Agent::EventLoop
  def dispatch_event(event, args); end
  def fire(event, *args); end
  def fire_after(interval, event); end
  def fire_every(interval, event); end
  def fire_timer(timer); end
  def fire_timers; end
  def initialize; end
  def next_timeout; end
  def on(event, &blk); end
  def prune_timers; end
  def reschedule_timer_for_event(e); end
  def run; end
  def run_once(nonblock = nil); end
  def set_timer(timer); end
  def stop; end
  def stopped?; end
  def wait_to_run(nonblock); end
  def wakeup; end
end
class NewRelic::Agent::StatsEngine::GCProfiler::GCSnapshot < Struct
  def gc_call_count; end
  def gc_call_count=(_); end
  def gc_time_s; end
  def gc_time_s=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
module NewRelic::Agent::StatsEngine::GCProfiler
  def self.gc_metric_name; end
  def self.init; end
  def self.record_delta(start_snapshot, end_snapshot); end
  def self.record_gc_metric(call_count, elapsed); end
  def self.reset; end
  def self.take_snapshot; end
end
class NewRelic::Agent::StatsEngine::GCProfiler::RailsBenchProfiler
  def call_count; end
  def call_time_s; end
  def reset; end
  def self.enabled?; end
end
class NewRelic::Agent::StatsEngine::GCProfiler::CoreGCProfiler
  def call_count; end
  def call_time_s; end
  def reset; end
  def self.enabled?; end
end
class NewRelic::Agent::InternalAgentError < StandardError
  def initialize(msg = nil); end
end
class NewRelic::Agent::StatsHash
  def ==(other); end
  def [](key); end
  def each; end
  def empty?; end
  def handle_stats_lookup_error(key, hash, error); end
  def harvested_at; end
  def harvested_at=(arg0); end
  def initialize(started_at = nil); end
  def marshal_dump; end
  def marshal_load(data); end
  def merge!(other); end
  def merge_or_insert(target, name, stats); end
  def merge_transaction_metrics!(txn_metrics, scope); end
  def record(metric_specs, value = nil, aux = nil, &blk); end
  def size; end
  def started_at; end
  def started_at=(arg0); end
  def to_h; end
end
class NewRelic::Agent::StatsHash::StatsHashLookupError < NewRelic::Agent::InternalAgentError
  def initialize(original_error, hash, metric_spec); end
end
class NewRelic::Agent::StatsEngine
  def apply_rules_to_metric_data(rules_engine, stats_hash); end
  def clear_stats; end
  def coerce_to_metric_spec_array(metric_names_or_specs, scope); end
  def harvest!; end
  def initialize; end
  def merge!(other_stats_hash); end
  def merge_transaction_metrics!(txn_metrics, scope); end
  def metric_rules; end
  def metric_rules=(arg0); end
  def record_scoped_and_unscoped_metrics(state, scoped_metric, summary_metrics = nil, value = nil, aux = nil, &blk); end
  def record_unscoped_metrics(state, metric_names, value = nil, aux = nil, &blk); end
  def reset!; end
  def tl_record_scoped_and_unscoped_metrics(scoped_metric, summary_metrics = nil, value = nil, aux = nil, &blk); end
  def tl_record_supportability_metric_count(metric, value); end
  def tl_record_unscoped_metrics(metric_names, value = nil, aux = nil, &blk); end
  def to_h; end
  def with_stats_lock; end
end
class NewRelic::Agent::Transaction::TransactionSampleBuffer
  def add_sample(sample); end
  def allow_sample?(sample); end
  def capacity; end
  def enabled?; end
  def full?; end
  def harvest_samples; end
  def initialize; end
  def max_capacity; end
  def reset!; end
  def samples; end
  def store(sample); end
  def store_previous(previous_samples); end
  def truncate_samples; end
  def truncate_samples_if_needed; end
  def visit_node(*arg0); end
end
class NewRelic::Agent::Transaction::SlowestSampleBuffer < NewRelic::Agent::Transaction::TransactionSampleBuffer
  def allow_sample?(sample); end
  def capacity; end
end
class NewRelic::Agent::Transaction::SyntheticsSampleBuffer < NewRelic::Agent::Transaction::TransactionSampleBuffer
  def allow_sample?(sample); end
  def capacity; end
  def truncate_samples; end
end
class NewRelic::Agent::Transaction::XraySampleBuffer < NewRelic::Agent::Transaction::TransactionSampleBuffer
  def add_sample(sample); end
  def allow_sample?(sample); end
  def capacity; end
  def enabled?; end
  def initialize; end
  def lookup_session_id(sample); end
  def truncate_samples; end
  def xray_session_collection; end
  def xray_session_collection=(arg0); end
end
class NewRelic::Agent::Transaction::TraceNode
  def [](key); end
  def []=(key, value); end
  def children; end
  def children=(arg0); end
  def count_nodes; end
  def duration; end
  def each_node(&block); end
  def each_node_with_nest_tracking(&block); end
  def end_trace(timestamp); end
  def entry_timestamp; end
  def exclusive_duration; end
  def exit_timestamp; end
  def exit_timestamp=(arg0); end
  def explain_sql; end
  def initialize(metric_name, relative_start, relative_end = nil, params = nil, parent = nil); end
  def metric_name; end
  def metric_name=(arg0); end
  def obfuscated_sql; end
  def params; end
  def params=(arg0); end
  def parent_node; end
  def parent_node=(s); end
  def path_string; end
  def to_array; end
  def to_debug_str(depth); end
  def to_s; end
  def to_s_compact; end
end
class NewRelic::Agent::Transaction::Trace
  def attributes; end
  def attributes=(arg0); end
  def attributes_for_tracer_destination; end
  def collect_explain_plans!; end
  def count_nodes; end
  def create_node(time_since_start, metric_name = nil); end
  def duration; end
  def each_node(&block); end
  def each_node_with_nest_tracking(&block); end
  def finished; end
  def finished=(arg0); end
  def forced?; end
  def guid; end
  def guid=(arg0); end
  def initialize(start_time); end
  def node_count; end
  def node_count=(arg0); end
  def prepare_sql_for_transmission!; end
  def prepare_to_send!; end
  def profile; end
  def profile=(arg0); end
  def root_node; end
  def sample_id; end
  def start_time; end
  def strip_sql!; end
  def synthetics_resource_id; end
  def threshold; end
  def threshold=(arg0); end
  def to_collector_array(encoder); end
  def to_s_compact; end
  def trace_tree(attributes_hash); end
  def transaction_name; end
  def transaction_name=(arg0); end
  def xray_session_id; end
  def xray_session_id=(arg0); end
end
module NewRelic::Agent::Transaction::TraceBuilder
  def build_trace(transaction); end
  def copy_attributes(transaction, trace); end
  def create_trace_node(transaction, segment, parent); end
  def process_segments(transaction, segment, parent, relationship_map); end
  extend NewRelic::Agent::Transaction::TraceBuilder
end
class NewRelic::Agent::TransactionSampler
  def count; end
  def enabled?; end
  def harvest!; end
  def harvest_from_sample_buffers; end
  def initialize; end
  def last_sample; end
  def merge!(previous); end
  def on_finishing_transaction(txn); end
  def prepare_samples(samples); end
  def reset!; end
  def store_sample(sample); end
  def xray_sample_buffer; end
end
class NewRelic::Agent::SqlSampler
  def disabled; end
  def distributed_trace_intrinsics(state); end
  def enabled?; end
  def harvest!; end
  def has_room?; end
  def initialize; end
  def merge!(sql_traces); end
  def notice_sql(sql, metric_name, config, duration, state = nil, explainer = nil, binds = nil, name = nil); end
  def notice_sql_statement(statement, metric_name, duration); end
  def on_finishing_transaction(state, name, time = nil); end
  def on_start_transaction(state, start_time, uri = nil); end
  def remove_shortest_trace; end
  def reset!; end
  def save_slow_sql(transaction_sql_data); end
  def should_add_trace?(sql_item); end
  def sql_traces; end
  def tl_transaction_data; end
end
class NewRelic::Agent::TransactionSqlData
  def guid; end
  def initialize; end
  def path; end
  def set_transaction_info(uri, guid); end
  def set_transaction_name(name); end
  def sql_data; end
  def uri; end
end
class NewRelic::Agent::SlowSql
  def backtrace; end
  def base_params; end
  def duration; end
  def explain; end
  def initialize(statement, metric_name, duration, backtrace = nil, params = nil); end
  def metric_name; end
  def normalize; end
  def obfuscate; end
  def prepare_to_send; end
  def sql; end
  def statement; end
end
class NewRelic::Agent::SqlTrace < NewRelic::Agent::Stats
  def aggregate(slow_sql, path, uri); end
  def aggregate_trace(trace); end
  def consistent_hash(string); end
  def database_metric_name; end
  def initialize(normalized_query, slow_sql, path, uri); end
  def need_to_explain?; end
  def need_to_obfuscate?; end
  def params; end
  def path; end
  def prepare_to_send; end
  def set_primary(slow_sql, path, uri); end
  def slow_sql; end
  def sql; end
  def sql_id; end
  def to_collector_array(encoder); end
  def url; end
  include NewRelic::Coerce
end
class NewRelic::Agent::Threading::BacktraceBase
  def add_child(child); end
  def add_child_unless_present(child); end
  def children; end
  def find_child(raw_line); end
  def initialize; end
end
class NewRelic::Agent::Threading::BacktraceRoot < NewRelic::Agent::Threading::BacktraceBase
  def ==(other); end
  def aggregate(backtrace); end
  def as_array; end
  def dump_string; end
  def flattened; end
  def initialize; end
end
class NewRelic::Agent::Threading::BacktraceNode < NewRelic::Agent::Threading::BacktraceBase
  def ==(other); end
  def as_array; end
  def complete_array_conversion; end
  def depth; end
  def depth=(arg0); end
  def dump_string(indent = nil); end
  def file; end
  def initialize(line); end
  def line_no; end
  def mark_for_array_conversion; end
  def method; end
  def parse_backtrace_frame(frame); end
  def raw_line; end
  def runnable_count; end
  def runnable_count=(arg0); end
  include NewRelic::Coerce
end
class NewRelic::Agent::Threading::ThreadProfile
  def aggregate(backtrace, bucket, thread); end
  def backtrace_count; end
  def command_arguments; end
  def convert_N_trace_nodes_to_arrays(count_to_keep); end
  def created_at; end
  def duration; end
  def empty?; end
  def failure_count; end
  def finished_at; end
  def finished_at=(arg0); end
  def generate_traces; end
  def increment_poll_count; end
  def initialize(command_arguments = nil); end
  def poll_count; end
  def profile_agent_code; end
  def profile_id; end
  def requested_period; end
  def sample_count; end
  def sample_period; end
  def to_collector_array(encoder); end
  def to_log_description; end
  def traces; end
  def unique_thread_count; end
  def xray?; end
  def xray_id; end
  include NewRelic::Coerce
end
class NewRelic::Agent::Commands::ThreadProfilerSession
  def enabled?; end
  def handle_start_command(agent_command); end
  def handle_stop_command(agent_command); end
  def harvest; end
  def initialize(backtrace_service); end
  def past_time?; end
  def raise_already_started_error; end
  def raise_command_error(msg); end
  def raise_thread_profiler_disabled; end
  def raise_unsupported_error; end
  def ready_to_harvest?; end
  def running?; end
  def start(agent_command); end
  def stop(report_data); end
  def stopped?; end
end
class NewRelic::Agent::ErrorTraceAggregator
  def add_to_error_queue(noticed_error); end
  def enabled?; end
  def harvest!; end
  def initialize(capacity); end
  def merge!(errors); end
  def notice_agent_error(exception); end
  def over_queue_limit?(message); end
  def register_config_callbacks; end
  def reset!; end
end
module NewRelic::Agent::TransactionErrorPrimitive
  def append_cat(payload, sample); end
  def append_distributed_trace_intrinsics(payload, sample); end
  def append_synthetics(payload, sample); end
  def create(noticed_error, payload); end
  def intrinsic_attributes_for(noticed_error, payload); end
  extend NewRelic::Agent::TransactionErrorPrimitive
end
class NewRelic::Agent::ErrorEventAggregator < NewRelic::Agent::EventAggregator
  def create_event(noticed_error, transaction_payload); end
  def record(noticed_error, transaction_payload = nil); end
end
class NewRelic::Agent::ErrorCollector
  def aggregated_metric_names(txn); end
  def blamed_metric_name(txn, options); end
  def create_noticed_error(exception, options); end
  def disabled?; end
  def drop_buffered_data; end
  def enabled?; end
  def error_event_aggregator; end
  def error_is_ignored?(error); end
  def error_trace_aggregator; end
  def exception_is_java_object?(exception); end
  def exception_tagged?(exception); end
  def extract_stack_trace(exception); end
  def filtered_by_error_filter?(error); end
  def filtered_error?(error); end
  def ignore(errors); end
  def increment_error_count!(state, exception, options = nil); end
  def initialize; end
  def initialize_ignored_errors(ignore_errors); end
  def notice_agent_error(exception); end
  def notice_error(exception, options = nil); end
  def self.ignore_error_filter; end
  def self.ignore_error_filter=(block); end
  def sense_method(object, method); end
  def skip_notice_error?(exception); end
  def tag_exception(exception); end
  def truncate_trace(trace, keep_frames = nil); end
end
class NewRelic::Agent::Sampler
  def id; end
  def initialize(id = nil); end
  def poll; end
  def self.enabled?; end
  def self.inherited(subclass); end
  def self.named(new_name); end
  def self.sampler_classes; end
  def self.shorthand_name; end
  def self.supported_on_this_platform?; end
end
module NewRelic::Agent::Datastores
  def self.notice_sql(query, scoped_metric, elapsed); end
  def self.notice_statement(statement, elapsed); end
  def self.trace(clazz, method_name, product, operation = nil); end
  def self.wrap(product, operation, collection = nil, callback = nil); end
end
module NewRelic::Agent::PipeChannelManager
  def channels; end
  def listener; end
  def register_report_channel(id); end
  extend NewRelic::Agent::PipeChannelManager
end
class NewRelic::Agent::PipeChannelManager::Pipe
  def after_fork_in_child; end
  def after_fork_in_parent; end
  def close; end
  def closed?; end
  def deserialize_message_length(data); end
  def eof?; end
  def in; end
  def in=(arg0); end
  def initialize; end
  def last_read; end
  def out; end
  def out=(arg0); end
  def parent_pid; end
  def read; end
  def serialize_message_length(data); end
  def write(data); end
end
class NewRelic::Agent::PipeChannelManager::Listener
  def clean_up_pipes; end
  def close_all_pipes; end
  def find_pipe_for_handle(out_handle); end
  def initialize; end
  def merge_data_from_pipe(pipe_handle); end
  def pipes; end
  def pipes=(arg0); end
  def register_pipe(id); end
  def select_timeout; end
  def select_timeout=(arg0); end
  def should_keep_listening?; end
  def start; end
  def started?; end
  def stop; end
  def stop_listener_thread; end
  def thread; end
  def timeout; end
  def timeout=(arg0); end
  def unmarshal(data); end
  def wake; end
  def wakeup; end
end
class NewRelic::Agent::Configuration::ManualSource < NewRelic::Agent::Configuration::DottedHash
  def initialize(hash); end
end
class NewRelic::Agent::RulesEngine::ReplacementRule
  def <=>(other); end
  def apply(string); end
  def apply_replacement(string); end
  def apply_to_each_segment(string); end
  def each_segment; end
  def eval_order; end
  def ignore; end
  def initialize(options); end
  def match_expression; end
  def matches?(string); end
  def replace_all; end
  def replacement; end
  def terminal?; end
  def terminate_chain; end
end
class NewRelic::Agent::RulesEngine::SegmentTermsRule
  def apply(string); end
  def collapse_adjacent_placeholder_segments(segments); end
  def initialize(options); end
  def matches?(string); end
  def prefix; end
  def prefix_matches_on_segment_boundary?(string); end
  def self.valid?(rule_spec); end
  def self.valid_prefix_segment_count?(prefix); end
  def terminal?; end
  def terms; end
end
class NewRelic::Agent::RulesEngine
  def apply_rules(rules, string); end
  def clear(*args, &block); end
  def each(*args, &block); end
  def initialize(rules = nil, segment_term_rules = nil); end
  def inspect(*args, &block); end
  def rename(original_string); end
  def self.create_metric_rules(connect_response); end
  def self.create_transaction_rules(connect_response); end
  def self.reject_rules_with_duplicate_prefixes!(rules); end
  def size(*args, &block); end
  extend Forwardable
  include Enumerable
end
module NewRelic::Agent::SystemInfo
  def self.boot_id; end
  def self.bsd?; end
  def self.clear_processor_info; end
  def self.darwin?; end
  def self.docker_container_id; end
  def self.get_processor_info; end
  def self.ip_addresses; end
  def self.linux?; end
  def self.num_logical_processors; end
  def self.num_physical_cores; end
  def self.num_physical_packages; end
  def self.os_version; end
  def self.parse_cgroup_ids(cgroup_info); end
  def self.parse_cpuinfo(cpuinfo); end
  def self.parse_docker_container_id(cgroup_info); end
  def self.parse_linux_meminfo_in_mib(meminfo); end
  def self.proc_try_read(path); end
  def self.processor_arch; end
  def self.ram_in_mib; end
  def self.ruby_os_identifier; end
  def self.sysctl_value(name); end
end
module NewRelic::Agent::External
  def get_response_metadata; end
  def obfuscator; end
  def process_request_metadata(request_metadata); end
  def start_segment(library: nil, uri: nil, procedure: nil); end
  extend NewRelic::Agent::External
end
module NewRelic::Agent::Instrumentation::IgnoreActions
  def self.is_filtered?(key, klass, action_name); end
end
module NewRelic::Agent::Instrumentation::ControllerInstrumentation
  def _is_filtered?(key); end
  def create_transaction_options(trace_options, category, state, queue_start_time); end
  def detect_queue_start_time(request); end
  def do_not_trace?; end
  def ignore_apdex?; end
  def ignore_enduser?; end
  def newrelic_request(args); end
  def newrelic_request_headers(request); end
  def newrelic_response_code; end
  def perform_action_with_newrelic_trace(*args, &block); end
  def self.included(clazz); end
end
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethodsShim
  def newrelic_ignore(*args); end
  def newrelic_ignore_apdex(*args); end
  def newrelic_ignore_enduser(*args); end
end
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::Shim
  def new_relic_trace_controller_action(*args); end
  def perform_action_with_newrelic_trace(*args); end
  def self.included(clazz); end
end
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods
  def add_transaction_tracer(method, options = nil); end
  def already_added_transaction_tracer?(target, with_method_name); end
  def build_method_names(traced_method, punctuation); end
  def generate_argument_list(options); end
  def newrelic_ignore(specifiers = nil); end
  def newrelic_ignore_apdex(specifiers = nil); end
  def newrelic_ignore_aspect(property, specifiers = nil); end
  def newrelic_ignore_enduser(specifiers = nil); end
  def newrelic_read_attr(attr_name); end
  def newrelic_write_attr(attr_name, value); end
  def parse_punctuation(method); end
end
class NewRelic::Agent::Instrumentation::ControllerInstrumentation::TransactionNamer
  def self.class_name(traced_obj, options = nil); end
  def self.name_for(txn, traced_obj, category, options = nil); end
  def self.path_name(traced_obj, options = nil); end
  def self.prefix_for_category(txn, category = nil); end
end
class NewRelic::Agent::Samplers::CpuSampler < NewRelic::Agent::Sampler
  def initialize; end
  def last_time; end
  def poll; end
  def record_system_util(value); end
  def record_systemtime(value); end
  def record_user_util(value); end
  def record_usertime(value); end
  def self.supported_on_this_platform?; end
end
class NewRelic::Agent::Samplers::MemorySampler < NewRelic::Agent::Sampler
  def initialize; end
  def platform; end
  def poll; end
  def sampler; end
  def sampler=(arg0); end
  def self.platform; end
  def self.supported_on_this_platform?; end
end
class NewRelic::Agent::Samplers::MemorySampler::Base
  def can_run?; end
  def get_sample; end
  def initialize; end
end
class NewRelic::Agent::Samplers::MemorySampler::JavaHeapSampler < NewRelic::Agent::Samplers::MemorySampler::Base
  def get_memory; end
  def to_s; end
end
class NewRelic::Agent::Samplers::MemorySampler::ShellPS < NewRelic::Agent::Samplers::MemorySampler::Base
  def get_memory; end
  def initialize(command); end
  def to_s; end
end
class NewRelic::Agent::Samplers::MemorySampler::ProcStatus < NewRelic::Agent::Samplers::MemorySampler::Base
  def get_memory; end
  def proc_status_file; end
  def to_s; end
end
class NewRelic::Agent::Samplers::ObjectSampler < NewRelic::Agent::Sampler
  def poll; end
  def self.supported_on_this_platform?; end
end
module NewRelic::DelayedJobInjection
  def worker_name; end
  def worker_name=(arg0); end
  extend NewRelic::DelayedJobInjection
end
class NewRelic::Agent::Samplers::DelayedJobSampler < NewRelic::Agent::Sampler
  def count(query); end
  def failed_jobs; end
  def initialize; end
  def locked_jobs; end
  def poll; end
  def queue_counts(column_name); end
  def record_counts_by(column_name, metric_node = nil); end
  def record_failed_jobs(value); end
  def record_locked_jobs(value); end
  def record_queue_length_metrics; end
  def self.supported_backend?; end
  def self.supported_on_this_platform?; end
end
class NewRelic::Agent::VM::Snapshot
  def constant_cache_invalidations; end
  def constant_cache_invalidations=(arg0); end
  def gc_runs; end
  def gc_runs=(arg0); end
  def gc_total_time; end
  def gc_total_time=(arg0); end
  def heap_free; end
  def heap_free=(arg0); end
  def heap_live; end
  def heap_live=(arg0); end
  def initialize; end
  def major_gc_count; end
  def major_gc_count=(arg0); end
  def method_cache_invalidations; end
  def method_cache_invalidations=(arg0); end
  def minor_gc_count; end
  def minor_gc_count=(arg0); end
  def taken_at; end
  def taken_at=(arg0); end
  def thread_count; end
  def thread_count=(arg0); end
  def total_allocated_object; end
  def total_allocated_object=(arg0); end
end
class NewRelic::Agent::VM::MriVM
  def gather_gc_stats(snap); end
  def gather_gc_time(snap); end
  def gather_ruby_vm_stats(snap); end
  def gather_stats(snap); end
  def gather_thread_stats(snap); end
  def snapshot; end
  def supports?(key); end
end
class NewRelic::Agent::VM::JRubyVM
  def gather_stats(snap); end
  def snapshot; end
  def supports?(key); end
end
module NewRelic::Agent::VM
  def self.create_vm; end
  def self.snapshot; end
  def self.vm; end
end
class NewRelic::Agent::Samplers::VMSampler < NewRelic::Agent::Sampler
  def initialize; end
  def on_transaction_finished(*_); end
  def poll; end
  def record_delta(snapshot, key, metric, txn_count); end
  def record_gauge_metric(metric_name, value); end
  def record_gc_runs_metric(snapshot, txn_count); end
  def record_heap_free_metric(snapshot); end
  def record_heap_live_metric(snapshot); end
  def record_thread_count_metric(snapshot); end
  def reset_transaction_count; end
  def setup_events(event_listener); end
  def take_snapshot; end
  def transaction_count; end
end
module NewRelic::Agent
  def add_custom_attributes(params); end
  def add_deferred_method_tracers_now; end
  def add_instrumentation(file_pattern); end
  def add_or_defer_method_tracer(receiver, method_name, metric_name_code, options); end
  def after_fork(options = nil); end
  def agent; end
  def agent=(new_instance); end
  def browser_timing_header; end
  def config; end
  def disable_all_tracing; end
  def disable_sql_recording; end
  def disable_transaction_tracing; end
  def drop_buffered_data; end
  def get_transaction_name; end
  def ignore_apdex; end
  def ignore_enduser; end
  def ignore_error_filter(&block); end
  def ignore_transaction; end
  def increment_metric(metric_name, amount = nil); end
  def instance; end
  def logger; end
  def logger=(log); end
  def manual_start(options = nil); end
  def notice_error(exception, options = nil); end
  def notify(event_type, *args); end
  def record_custom_event(event_type, event_attrs); end
  def record_metric(metric_name, value); end
  def register_report_channel(*args, &block); end
  def require_test_helper; end
  def reset_config; end
  def set_sql_obfuscator(type = nil, &block); end
  def set_transaction_name(name, options = nil); end
  def shutdown(options = nil); end
  def subscribe(event_type, &handler); end
  def tl_is_execution_traced?; end
  def tl_is_sql_recorded?; end
  def with_database_metric_name(model, method = nil, product = nil, &block); end
  extend Forwardable
  extend NewRelic::Agent
  extend NewRelic::SupportabilityHelper
end
class NewRelic::Agent::ForceRestartException < StandardError
  def message; end
end
class NewRelic::Control::Frameworks::Ruby < NewRelic::Control
  def env; end
  def init_config(options = nil); end
  def root; end
end
class NewRelic::Control::Frameworks::Rails < NewRelic::Control::Frameworks::Ruby
  def env; end
  def init_config(options = nil); end
  def install_agent_hooks(config); end
  def install_browser_monitoring(config); end
  def install_shim; end
  def rails_config; end
  def rails_root; end
  def rails_vendor_root; end
  def rails_version; end
  def root; end
end
class NewRelic::Control::Frameworks::Rails3 < NewRelic::Control::Frameworks::Rails
  def env; end
  def install_shim; end
  def rails_root; end
  def vendor_root; end
  def version; end
end
class NewRelic::Control::Frameworks::Rails4 < NewRelic::Control::Frameworks::Rails3
  def append_plugin_list; end
  def rails_gem_list; end
end
