# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/statsd-instrument/all/statsd-instrument.rbi
#
# statsd-instrument-2.3.2
class StatsD::Instrument::Metric
  def default_value; end
  def initialize(options = nil); end
  def inspect; end
  def metadata; end
  def metadata=(arg0); end
  def name; end
  def name=(arg0); end
  def normalize_name(name); end
  def sample_rate; end
  def sample_rate=(arg0); end
  def self.normalize_tags(tags); end
  def tags; end
  def tags=(arg0); end
  def to_s; end
  def type; end
  def type=(arg0); end
  def value; end
  def value=(arg0); end
end
class StatsD::Instrument::Backends::LoggerBackend < StatsD::Instrument::Backend
  def collect_metric(metric); end
  def initialize(logger); end
  def logger; end
  def logger=(arg0); end
end
class StatsD::Instrument::Backends::NullBackend < StatsD::Instrument::Backend
  def collect_metric(metric); end
end
class StatsD::Instrument::Backends::CaptureBackend < StatsD::Instrument::Backend
  def collect_metric(metric); end
  def collected_metrics; end
  def initialize; end
  def reset; end
end
class StatsD::Instrument::Backends::UDPBackend::DogStatsDProtocol
  def generate_metadata(metric, options); end
  def generate_packet(metric); end
end
class StatsD::Instrument::Backends::UDPBackend::StatsiteStatsDProtocol
  def generate_packet(metric); end
end
class StatsD::Instrument::Backends::UDPBackend::StatsDProtocol
  def generate_packet(metric); end
end
class StatsD::Instrument::Backends::UDPBackend < StatsD::Instrument::Backend
  def collect_metric(metric); end
  def host; end
  def host=(host); end
  def implementation; end
  def implementation=(value); end
  def initialize(server = nil, implementation = nil); end
  def invalidate_socket; end
  def port; end
  def port=(port); end
  def server=(connection_string); end
  def socket; end
  def write_packet(command); end
  include MonitorMixin
end
class StatsD::Instrument::Backend
  def collect_metric(metric); end
end
module StatsD::Instrument::Environment
  def default_backend; end
  def environment; end
  def setup; end
  extend StatsD::Instrument::Environment
end
module StatsD::Instrument::Helpers
  def capture_statsd_calls(&block); end
end
module StatsD::Instrument::Assertions
  def assert_no_statsd_calls(metric_name = nil, &block); end
  def assert_statsd_call(metric_type, metric_name, options = nil, &block); end
  def assert_statsd_calls(expected_metrics, &block); end
  def assert_statsd_distribution(metric_name, options = nil, &block); end
  def assert_statsd_gauge(metric_name, options = nil, &block); end
  def assert_statsd_histogram(metric_name, options = nil, &block); end
  def assert_statsd_increment(metric_name, options = nil, &block); end
  def assert_statsd_key_value(metric_name, options = nil, &block); end
  def assert_statsd_measure(metric_name, options = nil, &block); end
  def assert_statsd_set(metric_name, options = nil, &block); end
  def within_numeric_range?(object); end
  include StatsD::Instrument::Helpers
end
class StatsD::Instrument::MetricExpectation
  def default_value; end
  def ignore_tags; end
  def initialize(options = nil); end
  def inspect; end
  def matches(actual_metric); end
  def name; end
  def name=(arg0); end
  def sample_rate; end
  def sample_rate=(arg0); end
  def tags; end
  def tags=(arg0); end
  def times; end
  def times=(arg0); end
  def to_s; end
  def type; end
  def type=(arg0); end
  def value; end
  def value=(arg0); end
end
module StatsD
  def backend; end
  def backend=(arg0); end
  def collect_metric(type, name, value, metric_options); end
  def default_sample_rate; end
  def default_sample_rate=(arg0); end
  def distribution(key, value = nil, *metric_options, &block); end
  def event(title, text, *metric_options); end
  def gauge(key, value, *metric_options); end
  def hash_argument(args); end
  def histogram(key, value, *metric_options); end
  def increment(key, value = nil, *metric_options); end
  def key_value(key, value, *metric_options); end
  def logger; end
  def logger=(arg0); end
  def measure(key, value = nil, *metric_options, &block); end
  def parse_options(value, metric_options); end
  def prefix; end
  def prefix=(arg0); end
  def service_check(name, status, *metric_options); end
  def set(key, value, *metric_options); end
  extend StatsD
end
module StatsD::Instrument
  def add_to_method(method, name, action, &block); end
  def method_visibility(method); end
  def remove_from_method(method, name, action); end
  def self.duration; end
  def self.generate_metric_name(metric_name, callee, *args); end
  def statsd_count(method, name, *metric_options); end
  def statsd_count_if(method, name, *metric_options); end
  def statsd_count_success(method, name, *metric_options); end
  def statsd_distribution(method, name, *metric_options); end
  def statsd_instrumentation_for(method, name, action); end
  def statsd_instrumentations; end
  def statsd_measure(method, name, *metric_options); end
  def statsd_remove_count(method, name); end
  def statsd_remove_count_if(method, name); end
  def statsd_remove_count_success(method, name); end
  def statsd_remove_distribution(method, name); end
  def statsd_remove_measure(method, name); end
end
